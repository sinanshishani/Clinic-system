/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.7.3.0 (NJsonSchema v10.1.26.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

import * as moment from 'moment';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable()
export class AccountServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    authenticate(body?: TokenRequest | undefined): Observable<TokenDtoAppResponse> {
        let url_ = this.baseUrl + "/api/v1/accounts/authenticate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAuthenticate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAuthenticate(<any>response_);
                } catch (e) {
                    return <Observable<TokenDtoAppResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<TokenDtoAppResponse>><any>_observableThrow(response_);
        }));
    }

    protected processAuthenticate(response: HttpResponseBase): Observable<TokenDtoAppResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TokenDtoAppResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TokenDtoAppResponse>(<any>null);
    }
}

@Injectable()
export class AccountAllergicsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    allergies(body?: CreateAllergicInput | undefined): Observable<Int64AppResponse> {
        let url_ = this.baseUrl + "/api/v1/Lookups/account/allergies";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAllergies(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAllergies(<any>response_);
                } catch (e) {
                    return <Observable<Int64AppResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<Int64AppResponse>><any>_observableThrow(response_);
        }));
    }

    protected processAllergies(response: HttpResponseBase): Observable<Int64AppResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Int64AppResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Int64AppResponse>(<any>null);
    }

    /**
     * @param deletedOnly (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    allergies2(deletedOnly?: boolean | undefined, skipCount?: number | undefined, maxResultCount?: number | undefined): Observable<AllergiesOutputAppResponse> {
        let url_ = this.baseUrl + "/api/v1/Lookups/account/allergies?";
        if (deletedOnly === null)
            throw new Error("The parameter 'deletedOnly' cannot be null.");
        else if (deletedOnly !== undefined)
            url_ += "DeletedOnly=" + encodeURIComponent("" + deletedOnly) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAllergies2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAllergies2(<any>response_);
                } catch (e) {
                    return <Observable<AllergiesOutputAppResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<AllergiesOutputAppResponse>><any>_observableThrow(response_);
        }));
    }

    protected processAllergies2(response: HttpResponseBase): Observable<AllergiesOutputAppResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AllergiesOutputAppResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AllergiesOutputAppResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    allergies3(id: number, body?: EditAllergicInput | undefined): Observable<AppResponse> {
        let url_ = this.baseUrl + "/api/v1/Lookups/account/allergies/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAllergies3(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAllergies3(<any>response_);
                } catch (e) {
                    return <Observable<AppResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<AppResponse>><any>_observableThrow(response_);
        }));
    }

    protected processAllergies3(response: HttpResponseBase): Observable<AppResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AppResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AppResponse>(<any>null);
    }

    /**
     * @return Success
     */
    allergies4(id: number): Observable<LookupDtoAppResponse> {
        let url_ = this.baseUrl + "/api/v1/Lookups/account/allergies/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAllergies4(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAllergies4(<any>response_);
                } catch (e) {
                    return <Observable<LookupDtoAppResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<LookupDtoAppResponse>><any>_observableThrow(response_);
        }));
    }

    protected processAllergies4(response: HttpResponseBase): Observable<LookupDtoAppResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LookupDtoAppResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LookupDtoAppResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    status(id: number, body?: ChangeLookupStatusInput | undefined): Observable<AppResponse> {
        let url_ = this.baseUrl + "/api/v1/Lookups/account/allergies/{id}/status";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStatus(<any>response_);
                } catch (e) {
                    return <Observable<AppResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<AppResponse>><any>_observableThrow(response_);
        }));
    }

    protected processStatus(response: HttpResponseBase): Observable<AppResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AppResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AppResponse>(<any>null);
    }
}

@Injectable()
export class AccountBanksServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    banks(body?: CreateBankInput | undefined): Observable<Int64AppResponse> {
        let url_ = this.baseUrl + "/api/v1/Lookups/account/banks";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBanks(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBanks(<any>response_);
                } catch (e) {
                    return <Observable<Int64AppResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<Int64AppResponse>><any>_observableThrow(response_);
        }));
    }

    protected processBanks(response: HttpResponseBase): Observable<Int64AppResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Int64AppResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Int64AppResponse>(<any>null);
    }

    /**
     * @param deletedOnly (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    banks2(deletedOnly?: boolean | undefined, skipCount?: number | undefined, maxResultCount?: number | undefined): Observable<BanksOutputAppResponse> {
        let url_ = this.baseUrl + "/api/v1/Lookups/account/banks?";
        if (deletedOnly === null)
            throw new Error("The parameter 'deletedOnly' cannot be null.");
        else if (deletedOnly !== undefined)
            url_ += "DeletedOnly=" + encodeURIComponent("" + deletedOnly) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBanks2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBanks2(<any>response_);
                } catch (e) {
                    return <Observable<BanksOutputAppResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<BanksOutputAppResponse>><any>_observableThrow(response_);
        }));
    }

    protected processBanks2(response: HttpResponseBase): Observable<BanksOutputAppResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BanksOutputAppResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BanksOutputAppResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    banks3(id: number, body?: EditBankInput | undefined): Observable<AppResponse> {
        let url_ = this.baseUrl + "/api/v1/Lookups/account/banks/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBanks3(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBanks3(<any>response_);
                } catch (e) {
                    return <Observable<AppResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<AppResponse>><any>_observableThrow(response_);
        }));
    }

    protected processBanks3(response: HttpResponseBase): Observable<AppResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AppResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AppResponse>(<any>null);
    }

    /**
     * @return Success
     */
    banks4(id: number): Observable<LookupDtoAppResponse> {
        let url_ = this.baseUrl + "/api/v1/Lookups/account/banks/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBanks4(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBanks4(<any>response_);
                } catch (e) {
                    return <Observable<LookupDtoAppResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<LookupDtoAppResponse>><any>_observableThrow(response_);
        }));
    }

    protected processBanks4(response: HttpResponseBase): Observable<LookupDtoAppResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LookupDtoAppResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LookupDtoAppResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    status2(id: number, body?: ChangeLookupStatusInput | undefined): Observable<AppResponse> {
        let url_ = this.baseUrl + "/api/v1/Lookups/account/banks/{id}/status";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStatus2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStatus2(<any>response_);
                } catch (e) {
                    return <Observable<AppResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<AppResponse>><any>_observableThrow(response_);
        }));
    }

    protected processStatus2(response: HttpResponseBase): Observable<AppResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AppResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AppResponse>(<any>null);
    }
}

@Injectable()
export class AccountComplaintsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    complaints(body?: CreateComplaintInput | undefined): Observable<Int64AppResponse> {
        let url_ = this.baseUrl + "/api/v1/Lookups/account/complaints";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processComplaints(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processComplaints(<any>response_);
                } catch (e) {
                    return <Observable<Int64AppResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<Int64AppResponse>><any>_observableThrow(response_);
        }));
    }

    protected processComplaints(response: HttpResponseBase): Observable<Int64AppResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Int64AppResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Int64AppResponse>(<any>null);
    }

    /**
     * @param deletedOnly (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    complaints2(deletedOnly?: boolean | undefined, skipCount?: number | undefined, maxResultCount?: number | undefined): Observable<Int64AppResponse> {
        let url_ = this.baseUrl + "/api/v1/Lookups/account/complaints?";
        if (deletedOnly === null)
            throw new Error("The parameter 'deletedOnly' cannot be null.");
        else if (deletedOnly !== undefined)
            url_ += "DeletedOnly=" + encodeURIComponent("" + deletedOnly) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processComplaints2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processComplaints2(<any>response_);
                } catch (e) {
                    return <Observable<Int64AppResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<Int64AppResponse>><any>_observableThrow(response_);
        }));
    }

    protected processComplaints2(response: HttpResponseBase): Observable<Int64AppResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Int64AppResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Int64AppResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    complaints3(id: number, body?: EditComplaintInput | undefined): Observable<AppResponse> {
        let url_ = this.baseUrl + "/api/v1/Lookups/account/complaints/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processComplaints3(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processComplaints3(<any>response_);
                } catch (e) {
                    return <Observable<AppResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<AppResponse>><any>_observableThrow(response_);
        }));
    }

    protected processComplaints3(response: HttpResponseBase): Observable<AppResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AppResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AppResponse>(<any>null);
    }

    /**
     * @return Success
     */
    complaints4(id: number): Observable<Int64AppResponse> {
        let url_ = this.baseUrl + "/api/v1/Lookups/account/complaints/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processComplaints4(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processComplaints4(<any>response_);
                } catch (e) {
                    return <Observable<Int64AppResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<Int64AppResponse>><any>_observableThrow(response_);
        }));
    }

    protected processComplaints4(response: HttpResponseBase): Observable<Int64AppResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Int64AppResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Int64AppResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    status3(id: number, body?: ChangeLookupStatusInput | undefined): Observable<AppResponse> {
        let url_ = this.baseUrl + "/api/v1/Lookups/account/complaints/{id}/status";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStatus3(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStatus3(<any>response_);
                } catch (e) {
                    return <Observable<AppResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<AppResponse>><any>_observableThrow(response_);
        }));
    }

    protected processStatus3(response: HttpResponseBase): Observable<AppResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AppResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AppResponse>(<any>null);
    }
}

@Injectable()
export class AccountDiagnosesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    diagnoses(body?: CreateDiagnosisInput | undefined): Observable<Int64AppResponse> {
        let url_ = this.baseUrl + "/api/v1/Lookups/account/diagnoses";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDiagnoses(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDiagnoses(<any>response_);
                } catch (e) {
                    return <Observable<Int64AppResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<Int64AppResponse>><any>_observableThrow(response_);
        }));
    }

    protected processDiagnoses(response: HttpResponseBase): Observable<Int64AppResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Int64AppResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Int64AppResponse>(<any>null);
    }

    /**
     * @param deletedOnly (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    diagnoses2(deletedOnly?: boolean | undefined, skipCount?: number | undefined, maxResultCount?: number | undefined): Observable<DiagnosisOutputAppResponse> {
        let url_ = this.baseUrl + "/api/v1/Lookups/account/diagnoses?";
        if (deletedOnly === null)
            throw new Error("The parameter 'deletedOnly' cannot be null.");
        else if (deletedOnly !== undefined)
            url_ += "DeletedOnly=" + encodeURIComponent("" + deletedOnly) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDiagnoses2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDiagnoses2(<any>response_);
                } catch (e) {
                    return <Observable<DiagnosisOutputAppResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<DiagnosisOutputAppResponse>><any>_observableThrow(response_);
        }));
    }

    protected processDiagnoses2(response: HttpResponseBase): Observable<DiagnosisOutputAppResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DiagnosisOutputAppResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DiagnosisOutputAppResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    diagnoses3(id: number, body?: EditDiagnosisInput | undefined): Observable<AppResponse> {
        let url_ = this.baseUrl + "/api/v1/Lookups/account/diagnoses/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDiagnoses3(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDiagnoses3(<any>response_);
                } catch (e) {
                    return <Observable<AppResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<AppResponse>><any>_observableThrow(response_);
        }));
    }

    protected processDiagnoses3(response: HttpResponseBase): Observable<AppResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AppResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AppResponse>(<any>null);
    }

    /**
     * @return Success
     */
    diagnoses4(id: number): Observable<LookupDtoAppResponse> {
        let url_ = this.baseUrl + "/api/v1/Lookups/account/diagnoses/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDiagnoses4(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDiagnoses4(<any>response_);
                } catch (e) {
                    return <Observable<LookupDtoAppResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<LookupDtoAppResponse>><any>_observableThrow(response_);
        }));
    }

    protected processDiagnoses4(response: HttpResponseBase): Observable<LookupDtoAppResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LookupDtoAppResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LookupDtoAppResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    status4(id: number, body?: ChangeLookupStatusInput | undefined): Observable<AppResponse> {
        let url_ = this.baseUrl + "/api/v1/Lookups/account/diagnoses/{id}/status";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStatus4(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStatus4(<any>response_);
                } catch (e) {
                    return <Observable<AppResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<AppResponse>><any>_observableThrow(response_);
        }));
    }

    protected processStatus4(response: HttpResponseBase): Observable<AppResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AppResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AppResponse>(<any>null);
    }
}

@Injectable()
export class AccountDiseasesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    diseases(body?: CreateDiseaseInput | undefined): Observable<Int64AppResponse> {
        let url_ = this.baseUrl + "/api/v1/Lookups/account/diseases";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDiseases(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDiseases(<any>response_);
                } catch (e) {
                    return <Observable<Int64AppResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<Int64AppResponse>><any>_observableThrow(response_);
        }));
    }

    protected processDiseases(response: HttpResponseBase): Observable<Int64AppResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Int64AppResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Int64AppResponse>(<any>null);
    }

    /**
     * @param deletedOnly (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    diseases2(deletedOnly?: boolean | undefined, skipCount?: number | undefined, maxResultCount?: number | undefined): Observable<DiseasesOutputAppResponse> {
        let url_ = this.baseUrl + "/api/v1/Lookups/account/diseases?";
        if (deletedOnly === null)
            throw new Error("The parameter 'deletedOnly' cannot be null.");
        else if (deletedOnly !== undefined)
            url_ += "DeletedOnly=" + encodeURIComponent("" + deletedOnly) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDiseases2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDiseases2(<any>response_);
                } catch (e) {
                    return <Observable<DiseasesOutputAppResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<DiseasesOutputAppResponse>><any>_observableThrow(response_);
        }));
    }

    protected processDiseases2(response: HttpResponseBase): Observable<DiseasesOutputAppResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DiseasesOutputAppResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DiseasesOutputAppResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    diseases3(id: number, body?: EditDiseaseInput | undefined): Observable<AppResponse> {
        let url_ = this.baseUrl + "/api/v1/Lookups/account/diseases/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDiseases3(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDiseases3(<any>response_);
                } catch (e) {
                    return <Observable<AppResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<AppResponse>><any>_observableThrow(response_);
        }));
    }

    protected processDiseases3(response: HttpResponseBase): Observable<AppResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AppResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AppResponse>(<any>null);
    }

    /**
     * @return Success
     */
    diseases4(id: number): Observable<LookupDtoAppResponse> {
        let url_ = this.baseUrl + "/api/v1/Lookups/account/diseases/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDiseases4(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDiseases4(<any>response_);
                } catch (e) {
                    return <Observable<LookupDtoAppResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<LookupDtoAppResponse>><any>_observableThrow(response_);
        }));
    }

    protected processDiseases4(response: HttpResponseBase): Observable<LookupDtoAppResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LookupDtoAppResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LookupDtoAppResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    status5(id: number, body?: ChangeLookupStatusInput | undefined): Observable<AppResponse> {
        let url_ = this.baseUrl + "/api/v1/Lookups/account/diseases/{id}/status";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStatus5(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStatus5(<any>response_);
                } catch (e) {
                    return <Observable<AppResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<AppResponse>><any>_observableThrow(response_);
        }));
    }

    protected processStatus5(response: HttpResponseBase): Observable<AppResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AppResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AppResponse>(<any>null);
    }
}

@Injectable()
export class AccountMedicalVisitProceduresServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    medicalVisitProcedures(body?: CreateMedicalVisitProcedureInput | undefined): Observable<Int64AppResponse> {
        let url_ = this.baseUrl + "/api/v1/Lookups/account/medicalVisitProcedures";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMedicalVisitProcedures(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMedicalVisitProcedures(<any>response_);
                } catch (e) {
                    return <Observable<Int64AppResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<Int64AppResponse>><any>_observableThrow(response_);
        }));
    }

    protected processMedicalVisitProcedures(response: HttpResponseBase): Observable<Int64AppResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Int64AppResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Int64AppResponse>(<any>null);
    }

    /**
     * @param deletedOnly (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    medicalVisitProcedures2(deletedOnly?: boolean | undefined, skipCount?: number | undefined, maxResultCount?: number | undefined): Observable<MedicalVisitProceduresOutputAppResponse> {
        let url_ = this.baseUrl + "/api/v1/Lookups/account/medicalVisitProcedures?";
        if (deletedOnly === null)
            throw new Error("The parameter 'deletedOnly' cannot be null.");
        else if (deletedOnly !== undefined)
            url_ += "DeletedOnly=" + encodeURIComponent("" + deletedOnly) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMedicalVisitProcedures2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMedicalVisitProcedures2(<any>response_);
                } catch (e) {
                    return <Observable<MedicalVisitProceduresOutputAppResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<MedicalVisitProceduresOutputAppResponse>><any>_observableThrow(response_);
        }));
    }

    protected processMedicalVisitProcedures2(response: HttpResponseBase): Observable<MedicalVisitProceduresOutputAppResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MedicalVisitProceduresOutputAppResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MedicalVisitProceduresOutputAppResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    medicalVisitProcedures3(id: number, body?: EditMedicalVisitProcedureInput | undefined): Observable<AppResponse> {
        let url_ = this.baseUrl + "/api/v1/Lookups/account/medicalVisitProcedures/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMedicalVisitProcedures3(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMedicalVisitProcedures3(<any>response_);
                } catch (e) {
                    return <Observable<AppResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<AppResponse>><any>_observableThrow(response_);
        }));
    }

    protected processMedicalVisitProcedures3(response: HttpResponseBase): Observable<AppResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AppResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AppResponse>(<any>null);
    }

    /**
     * @return Success
     */
    medicalVisitProcedures4(id: number): Observable<LookupDtoAppResponse> {
        let url_ = this.baseUrl + "/api/v1/Lookups/account/medicalVisitProcedures/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMedicalVisitProcedures4(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMedicalVisitProcedures4(<any>response_);
                } catch (e) {
                    return <Observable<LookupDtoAppResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<LookupDtoAppResponse>><any>_observableThrow(response_);
        }));
    }

    protected processMedicalVisitProcedures4(response: HttpResponseBase): Observable<LookupDtoAppResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LookupDtoAppResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LookupDtoAppResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    status6(id: number, body?: ChangeLookupStatusInput | undefined): Observable<AppResponse> {
        let url_ = this.baseUrl + "/api/v1/Lookups/account/medicalVisitProcedures/{id}/status";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStatus6(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStatus6(<any>response_);
                } catch (e) {
                    return <Observable<AppResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<AppResponse>><any>_observableThrow(response_);
        }));
    }

    protected processStatus6(response: HttpResponseBase): Observable<AppResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AppResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AppResponse>(<any>null);
    }
}

@Injectable()
export class AccountSurgeriesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    surgeries(body?: CreateSurgeryInput | undefined): Observable<Int64AppResponse> {
        let url_ = this.baseUrl + "/api/v1/Lookups/account/surgeries";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSurgeries(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSurgeries(<any>response_);
                } catch (e) {
                    return <Observable<Int64AppResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<Int64AppResponse>><any>_observableThrow(response_);
        }));
    }

    protected processSurgeries(response: HttpResponseBase): Observable<Int64AppResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Int64AppResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Int64AppResponse>(<any>null);
    }

    /**
     * @param deletedOnly (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    surgeries2(deletedOnly?: boolean | undefined, skipCount?: number | undefined, maxResultCount?: number | undefined): Observable<SurgeriesOutputAppResponse> {
        let url_ = this.baseUrl + "/api/v1/Lookups/account/surgeries?";
        if (deletedOnly === null)
            throw new Error("The parameter 'deletedOnly' cannot be null.");
        else if (deletedOnly !== undefined)
            url_ += "DeletedOnly=" + encodeURIComponent("" + deletedOnly) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSurgeries2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSurgeries2(<any>response_);
                } catch (e) {
                    return <Observable<SurgeriesOutputAppResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<SurgeriesOutputAppResponse>><any>_observableThrow(response_);
        }));
    }

    protected processSurgeries2(response: HttpResponseBase): Observable<SurgeriesOutputAppResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SurgeriesOutputAppResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SurgeriesOutputAppResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    surgeries3(id: number, body?: EditSurgeryInput | undefined): Observable<AppResponse> {
        let url_ = this.baseUrl + "/api/v1/Lookups/account/surgeries/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSurgeries3(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSurgeries3(<any>response_);
                } catch (e) {
                    return <Observable<AppResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<AppResponse>><any>_observableThrow(response_);
        }));
    }

    protected processSurgeries3(response: HttpResponseBase): Observable<AppResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AppResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AppResponse>(<any>null);
    }

    /**
     * @return Success
     */
    surgeries4(id: number): Observable<SurgeryDtoAppResponse> {
        let url_ = this.baseUrl + "/api/v1/Lookups/account/surgeries/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSurgeries4(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSurgeries4(<any>response_);
                } catch (e) {
                    return <Observable<SurgeryDtoAppResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<SurgeryDtoAppResponse>><any>_observableThrow(response_);
        }));
    }

    protected processSurgeries4(response: HttpResponseBase): Observable<SurgeryDtoAppResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SurgeryDtoAppResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SurgeryDtoAppResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    status7(id: number, body?: ChangeLookupStatusInput | undefined): Observable<AppResponse> {
        let url_ = this.baseUrl + "/api/v1/Lookups/account/surgeries/{id}/status";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStatus7(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStatus7(<any>response_);
                } catch (e) {
                    return <Observable<AppResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<AppResponse>><any>_observableThrow(response_);
        }));
    }

    protected processStatus7(response: HttpResponseBase): Observable<AppResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AppResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AppResponse>(<any>null);
    }
}

@Injectable()
export class AccountSurgeryProceduresServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    surgeryProcedures(body?: CreateSurgeryProcedureInput | undefined): Observable<Int64AppResponse> {
        let url_ = this.baseUrl + "/api/v1/Lookups/account/surgeryProcedures";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSurgeryProcedures(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSurgeryProcedures(<any>response_);
                } catch (e) {
                    return <Observable<Int64AppResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<Int64AppResponse>><any>_observableThrow(response_);
        }));
    }

    protected processSurgeryProcedures(response: HttpResponseBase): Observable<Int64AppResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Int64AppResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Int64AppResponse>(<any>null);
    }

    /**
     * @param deletedOnly (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    surgeryProcedures2(deletedOnly?: boolean | undefined, skipCount?: number | undefined, maxResultCount?: number | undefined): Observable<SurgeryProceduresOutputAppResponse> {
        let url_ = this.baseUrl + "/api/v1/Lookups/account/surgeryProcedures?";
        if (deletedOnly === null)
            throw new Error("The parameter 'deletedOnly' cannot be null.");
        else if (deletedOnly !== undefined)
            url_ += "DeletedOnly=" + encodeURIComponent("" + deletedOnly) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSurgeryProcedures2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSurgeryProcedures2(<any>response_);
                } catch (e) {
                    return <Observable<SurgeryProceduresOutputAppResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<SurgeryProceduresOutputAppResponse>><any>_observableThrow(response_);
        }));
    }

    protected processSurgeryProcedures2(response: HttpResponseBase): Observable<SurgeryProceduresOutputAppResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SurgeryProceduresOutputAppResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SurgeryProceduresOutputAppResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    surgeryProcedures3(id: number, body?: EditSurgeryProcedureInput | undefined): Observable<AppResponse> {
        let url_ = this.baseUrl + "/api/v1/Lookups/account/surgeryProcedures/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSurgeryProcedures3(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSurgeryProcedures3(<any>response_);
                } catch (e) {
                    return <Observable<AppResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<AppResponse>><any>_observableThrow(response_);
        }));
    }

    protected processSurgeryProcedures3(response: HttpResponseBase): Observable<AppResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AppResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AppResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    status8(id: number, body?: ChangeLookupStatusInput | undefined): Observable<AppResponse> {
        let url_ = this.baseUrl + "/api/v1/Lookups/account/surgeryProcedures/{id}/status";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStatus8(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStatus8(<any>response_);
                } catch (e) {
                    return <Observable<AppResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<AppResponse>><any>_observableThrow(response_);
        }));
    }

    protected processStatus8(response: HttpResponseBase): Observable<AppResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AppResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AppResponse>(<any>null);
    }
}

@Injectable()
export class HospitalsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    hospitals(body?: HospitalInput | undefined): Observable<Int64AppResponse> {
        let url_ = this.baseUrl + "/api/v1/Hospitals";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processHospitals(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processHospitals(<any>response_);
                } catch (e) {
                    return <Observable<Int64AppResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<Int64AppResponse>><any>_observableThrow(response_);
        }));
    }

    protected processHospitals(response: HttpResponseBase): Observable<Int64AppResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Int64AppResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Int64AppResponse>(<any>null);
    }

    /**
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    hospitals2(skipCount?: number | undefined, maxResultCount?: number | undefined): Observable<HospitalsQueryOutputAppResponse> {
        let url_ = this.baseUrl + "/api/v1/Hospitals?";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processHospitals2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processHospitals2(<any>response_);
                } catch (e) {
                    return <Observable<HospitalsQueryOutputAppResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<HospitalsQueryOutputAppResponse>><any>_observableThrow(response_);
        }));
    }

    protected processHospitals2(response: HttpResponseBase): Observable<HospitalsQueryOutputAppResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HospitalsQueryOutputAppResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HospitalsQueryOutputAppResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    hospitals3(id: number, body?: HospitalInput | undefined): Observable<AppResponse> {
        let url_ = this.baseUrl + "/api/v1/Hospitals/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processHospitals3(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processHospitals3(<any>response_);
                } catch (e) {
                    return <Observable<AppResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<AppResponse>><any>_observableThrow(response_);
        }));
    }

    protected processHospitals3(response: HttpResponseBase): Observable<AppResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AppResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AppResponse>(<any>null);
    }

    /**
     * @return Success
     */
    hospitals4(id: number): Observable<HospitalDtoAppResponse> {
        let url_ = this.baseUrl + "/api/v1/Hospitals/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processHospitals4(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processHospitals4(<any>response_);
                } catch (e) {
                    return <Observable<HospitalDtoAppResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<HospitalDtoAppResponse>><any>_observableThrow(response_);
        }));
    }

    protected processHospitals4(response: HttpResponseBase): Observable<HospitalDtoAppResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HospitalDtoAppResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HospitalDtoAppResponse>(<any>null);
    }

    /**
     * @param api_version (optional) 
     * @return Success
     */
    names(api_version?: string | undefined): Observable<StringIEnumerableAppResponse> {
        let url_ = this.baseUrl + "/names?";
        if (api_version === null)
            throw new Error("The parameter 'api_version' cannot be null.");
        else if (api_version !== undefined)
            url_ += "api-version=" + encodeURIComponent("" + api_version) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processNames(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processNames(<any>response_);
                } catch (e) {
                    return <Observable<StringIEnumerableAppResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<StringIEnumerableAppResponse>><any>_observableThrow(response_);
        }));
    }

    protected processNames(response: HttpResponseBase): Observable<StringIEnumerableAppResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringIEnumerableAppResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StringIEnumerableAppResponse>(<any>null);
    }
}

@Injectable()
export class PatientsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    patients(body?: CreatePatientInput | undefined): Observable<AppResponse> {
        let url_ = this.baseUrl + "/api/v1/patients";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPatients(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPatients(<any>response_);
                } catch (e) {
                    return <Observable<AppResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<AppResponse>><any>_observableThrow(response_);
        }));
    }

    protected processPatients(response: HttpResponseBase): Observable<AppResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AppResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AppResponse>(<any>null);
    }

    /**
     * @return Success
     */
    patients2(): Observable<PatientsQueryOutputAppResponse> {
        let url_ = this.baseUrl + "/api/v1/patients";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPatients2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPatients2(<any>response_);
                } catch (e) {
                    return <Observable<PatientsQueryOutputAppResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<PatientsQueryOutputAppResponse>><any>_observableThrow(response_);
        }));
    }

    protected processPatients2(response: HttpResponseBase): Observable<PatientsQueryOutputAppResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PatientsQueryOutputAppResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PatientsQueryOutputAppResponse>(<any>null);
    }
}

@Injectable()
export class SystemAccountSubTypeServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    accountSubType(body?: SystemAccountSubTypeInput | undefined): Observable<Int64AppResponse> {
        let url_ = this.baseUrl + "/api/v1/Lookups/system/accountSubType";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAccountSubType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAccountSubType(<any>response_);
                } catch (e) {
                    return <Observable<Int64AppResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<Int64AppResponse>><any>_observableThrow(response_);
        }));
    }

    protected processAccountSubType(response: HttpResponseBase): Observable<Int64AppResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Int64AppResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Int64AppResponse>(<any>null);
    }

    /**
     * @param deletedOnly (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    accountSubType2(deletedOnly?: boolean | undefined, skipCount?: number | undefined, maxResultCount?: number | undefined): Observable<SystemAccountSubTypesOutputAppResponse> {
        let url_ = this.baseUrl + "/api/v1/Lookups/system/accountSubType?";
        if (deletedOnly === null)
            throw new Error("The parameter 'deletedOnly' cannot be null.");
        else if (deletedOnly !== undefined)
            url_ += "DeletedOnly=" + encodeURIComponent("" + deletedOnly) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAccountSubType2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAccountSubType2(<any>response_);
                } catch (e) {
                    return <Observable<SystemAccountSubTypesOutputAppResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<SystemAccountSubTypesOutputAppResponse>><any>_observableThrow(response_);
        }));
    }

    protected processAccountSubType2(response: HttpResponseBase): Observable<SystemAccountSubTypesOutputAppResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SystemAccountSubTypesOutputAppResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SystemAccountSubTypesOutputAppResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    accountSubType3(id: number, body?: SystemAccountSubTypeInput | undefined): Observable<AppResponse> {
        let url_ = this.baseUrl + "/api/v1/Lookups/system/accountSubType/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAccountSubType3(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAccountSubType3(<any>response_);
                } catch (e) {
                    return <Observable<AppResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<AppResponse>><any>_observableThrow(response_);
        }));
    }

    protected processAccountSubType3(response: HttpResponseBase): Observable<AppResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AppResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AppResponse>(<any>null);
    }

    /**
     * @return Success
     */
    accountSubType4(id: number): Observable<SystemAccountSubTypeDtoAppResponse> {
        let url_ = this.baseUrl + "/api/v1/Lookups/system/accountSubType/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAccountSubType4(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAccountSubType4(<any>response_);
                } catch (e) {
                    return <Observable<SystemAccountSubTypeDtoAppResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<SystemAccountSubTypeDtoAppResponse>><any>_observableThrow(response_);
        }));
    }

    protected processAccountSubType4(response: HttpResponseBase): Observable<SystemAccountSubTypeDtoAppResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SystemAccountSubTypeDtoAppResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SystemAccountSubTypeDtoAppResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    status9(id: number, body?: ChangeLookupStatusInput | undefined): Observable<AppResponse> {
        let url_ = this.baseUrl + "/api/v1/Lookups/system/accountSubType/{id}/status";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStatus9(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStatus9(<any>response_);
                } catch (e) {
                    return <Observable<AppResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<AppResponse>><any>_observableThrow(response_);
        }));
    }

    protected processStatus9(response: HttpResponseBase): Observable<AppResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AppResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AppResponse>(<any>null);
    }
}

@Injectable()
export class SystemAccountTypeServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    accountTypes(body?: CreateSystemAccountTypeInput | undefined): Observable<Int64AppResponse> {
        let url_ = this.baseUrl + "/api/v1/Lookups/system/accountTypes";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAccountTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAccountTypes(<any>response_);
                } catch (e) {
                    return <Observable<Int64AppResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<Int64AppResponse>><any>_observableThrow(response_);
        }));
    }

    protected processAccountTypes(response: HttpResponseBase): Observable<Int64AppResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Int64AppResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Int64AppResponse>(<any>null);
    }

    /**
     * @param deletedOnly (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    accountTypes2(deletedOnly?: boolean | undefined, skipCount?: number | undefined, maxResultCount?: number | undefined): Observable<SystemAccountTypesOutputAppResponse> {
        let url_ = this.baseUrl + "/api/v1/Lookups/system/accountTypes?";
        if (deletedOnly === null)
            throw new Error("The parameter 'deletedOnly' cannot be null.");
        else if (deletedOnly !== undefined)
            url_ += "DeletedOnly=" + encodeURIComponent("" + deletedOnly) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAccountTypes2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAccountTypes2(<any>response_);
                } catch (e) {
                    return <Observable<SystemAccountTypesOutputAppResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<SystemAccountTypesOutputAppResponse>><any>_observableThrow(response_);
        }));
    }

    protected processAccountTypes2(response: HttpResponseBase): Observable<SystemAccountTypesOutputAppResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SystemAccountTypesOutputAppResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SystemAccountTypesOutputAppResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    accountTypes3(id: number, body?: EditSystemAccountTypeInput | undefined): Observable<AppResponse> {
        let url_ = this.baseUrl + "/api/v1/Lookups/system/accountTypes/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAccountTypes3(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAccountTypes3(<any>response_);
                } catch (e) {
                    return <Observable<AppResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<AppResponse>><any>_observableThrow(response_);
        }));
    }

    protected processAccountTypes3(response: HttpResponseBase): Observable<AppResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AppResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AppResponse>(<any>null);
    }

    /**
     * @return Success
     */
    accountTypes4(id: number): Observable<SystemAccountTypeDtoAppResponse> {
        let url_ = this.baseUrl + "/api/v1/Lookups/system/accountTypes/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAccountTypes4(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAccountTypes4(<any>response_);
                } catch (e) {
                    return <Observable<SystemAccountTypeDtoAppResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<SystemAccountTypeDtoAppResponse>><any>_observableThrow(response_);
        }));
    }

    protected processAccountTypes4(response: HttpResponseBase): Observable<SystemAccountTypeDtoAppResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SystemAccountTypeDtoAppResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SystemAccountTypeDtoAppResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    status10(id: number, body?: ChangeLookupStatusInput | undefined): Observable<AppResponse> {
        let url_ = this.baseUrl + "/api/v1/Lookups/system/accountTypes/{id}/status";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStatus10(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStatus10(<any>response_);
                } catch (e) {
                    return <Observable<AppResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<AppResponse>><any>_observableThrow(response_);
        }));
    }

    protected processStatus10(response: HttpResponseBase): Observable<AppResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AppResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AppResponse>(<any>null);
    }
}

@Injectable()
export class SystemAllergicServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    allergic(body?: CreateSystemAllergicInput | undefined): Observable<Int64AppResponse> {
        let url_ = this.baseUrl + "/api/v1/Lookups/system/allergic";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAllergic(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAllergic(<any>response_);
                } catch (e) {
                    return <Observable<Int64AppResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<Int64AppResponse>><any>_observableThrow(response_);
        }));
    }

    protected processAllergic(response: HttpResponseBase): Observable<Int64AppResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Int64AppResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Int64AppResponse>(<any>null);
    }

    /**
     * @param deletedOnly (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    allergic2(deletedOnly?: boolean | undefined, skipCount?: number | undefined, maxResultCount?: number | undefined): Observable<SystemAllergiesOutputAppResponse> {
        let url_ = this.baseUrl + "/api/v1/Lookups/system/allergic?";
        if (deletedOnly === null)
            throw new Error("The parameter 'deletedOnly' cannot be null.");
        else if (deletedOnly !== undefined)
            url_ += "DeletedOnly=" + encodeURIComponent("" + deletedOnly) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAllergic2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAllergic2(<any>response_);
                } catch (e) {
                    return <Observable<SystemAllergiesOutputAppResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<SystemAllergiesOutputAppResponse>><any>_observableThrow(response_);
        }));
    }

    protected processAllergic2(response: HttpResponseBase): Observable<SystemAllergiesOutputAppResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SystemAllergiesOutputAppResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SystemAllergiesOutputAppResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    allergic3(id: number, body?: EditSystemAllergicInput | undefined): Observable<AppResponse> {
        let url_ = this.baseUrl + "/api/v1/Lookups/system/allergic/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAllergic3(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAllergic3(<any>response_);
                } catch (e) {
                    return <Observable<AppResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<AppResponse>><any>_observableThrow(response_);
        }));
    }

    protected processAllergic3(response: HttpResponseBase): Observable<AppResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AppResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AppResponse>(<any>null);
    }

    /**
     * @return Success
     */
    allergic4(id: number): Observable<SystemAllergicDtoAppResponse> {
        let url_ = this.baseUrl + "/api/v1/Lookups/system/allergic/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAllergic4(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAllergic4(<any>response_);
                } catch (e) {
                    return <Observable<SystemAllergicDtoAppResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<SystemAllergicDtoAppResponse>><any>_observableThrow(response_);
        }));
    }

    protected processAllergic4(response: HttpResponseBase): Observable<SystemAllergicDtoAppResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SystemAllergicDtoAppResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SystemAllergicDtoAppResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    status11(id: number, body?: ChangeLookupStatusInput | undefined): Observable<AppResponse> {
        let url_ = this.baseUrl + "/api/v1/Lookups/system/allergic/{id}/status";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStatus11(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStatus11(<any>response_);
                } catch (e) {
                    return <Observable<AppResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<AppResponse>><any>_observableThrow(response_);
        }));
    }

    protected processStatus11(response: HttpResponseBase): Observable<AppResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AppResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AppResponse>(<any>null);
    }
}

@Injectable()
export class SystemBankServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    bank(body?: CreateSystemBankInput | undefined): Observable<Int64AppResponse> {
        let url_ = this.baseUrl + "/api/v1/Lookups/system/bank";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBank(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBank(<any>response_);
                } catch (e) {
                    return <Observable<Int64AppResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<Int64AppResponse>><any>_observableThrow(response_);
        }));
    }

    protected processBank(response: HttpResponseBase): Observable<Int64AppResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Int64AppResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Int64AppResponse>(<any>null);
    }

    /**
     * @param deletedOnly (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    bank2(deletedOnly?: boolean | undefined, skipCount?: number | undefined, maxResultCount?: number | undefined): Observable<SystemBanksOutputAppResponse> {
        let url_ = this.baseUrl + "/api/v1/Lookups/system/bank?";
        if (deletedOnly === null)
            throw new Error("The parameter 'deletedOnly' cannot be null.");
        else if (deletedOnly !== undefined)
            url_ += "DeletedOnly=" + encodeURIComponent("" + deletedOnly) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBank2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBank2(<any>response_);
                } catch (e) {
                    return <Observable<SystemBanksOutputAppResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<SystemBanksOutputAppResponse>><any>_observableThrow(response_);
        }));
    }

    protected processBank2(response: HttpResponseBase): Observable<SystemBanksOutputAppResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SystemBanksOutputAppResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SystemBanksOutputAppResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    bank3(id: number, body?: EditSystemBankInput | undefined): Observable<AppResponse> {
        let url_ = this.baseUrl + "/api/v1/Lookups/system/bank/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBank3(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBank3(<any>response_);
                } catch (e) {
                    return <Observable<AppResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<AppResponse>><any>_observableThrow(response_);
        }));
    }

    protected processBank3(response: HttpResponseBase): Observable<AppResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AppResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AppResponse>(<any>null);
    }

    /**
     * @return Success
     */
    bank4(id: number): Observable<SystemBankDtoAppResponse> {
        let url_ = this.baseUrl + "/api/v1/Lookups/system/bank/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBank4(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBank4(<any>response_);
                } catch (e) {
                    return <Observable<SystemBankDtoAppResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<SystemBankDtoAppResponse>><any>_observableThrow(response_);
        }));
    }

    protected processBank4(response: HttpResponseBase): Observable<SystemBankDtoAppResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SystemBankDtoAppResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SystemBankDtoAppResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    bank5(id: number, body?: ChangeLookupStatusInput | undefined): Observable<AppResponse> {
        let url_ = this.baseUrl + "/api/v1/Lookups/system/bank/{id}status";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBank5(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBank5(<any>response_);
                } catch (e) {
                    return <Observable<AppResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<AppResponse>><any>_observableThrow(response_);
        }));
    }

    protected processBank5(response: HttpResponseBase): Observable<AppResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AppResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AppResponse>(<any>null);
    }
}

@Injectable()
export class SystemComplaintServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    complaint(body?: CreateSystemComplaintInput | undefined): Observable<Int64AppResponse> {
        let url_ = this.baseUrl + "/api/v1/Lookups/system/complaint";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processComplaint(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processComplaint(<any>response_);
                } catch (e) {
                    return <Observable<Int64AppResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<Int64AppResponse>><any>_observableThrow(response_);
        }));
    }

    protected processComplaint(response: HttpResponseBase): Observable<Int64AppResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Int64AppResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Int64AppResponse>(<any>null);
    }

    /**
     * @param deletedOnly (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    complaint2(deletedOnly?: boolean | undefined, skipCount?: number | undefined, maxResultCount?: number | undefined): Observable<SystemComplaintsOutputAppResponse> {
        let url_ = this.baseUrl + "/api/v1/Lookups/system/complaint?";
        if (deletedOnly === null)
            throw new Error("The parameter 'deletedOnly' cannot be null.");
        else if (deletedOnly !== undefined)
            url_ += "DeletedOnly=" + encodeURIComponent("" + deletedOnly) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processComplaint2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processComplaint2(<any>response_);
                } catch (e) {
                    return <Observable<SystemComplaintsOutputAppResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<SystemComplaintsOutputAppResponse>><any>_observableThrow(response_);
        }));
    }

    protected processComplaint2(response: HttpResponseBase): Observable<SystemComplaintsOutputAppResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SystemComplaintsOutputAppResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SystemComplaintsOutputAppResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    complaint3(id: number, body?: EditSystemComplaintInput | undefined): Observable<AppResponse> {
        let url_ = this.baseUrl + "/api/v1/Lookups/system/complaint/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processComplaint3(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processComplaint3(<any>response_);
                } catch (e) {
                    return <Observable<AppResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<AppResponse>><any>_observableThrow(response_);
        }));
    }

    protected processComplaint3(response: HttpResponseBase): Observable<AppResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AppResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AppResponse>(<any>null);
    }

    /**
     * @return Success
     */
    complaint4(id: number): Observable<SystemComplaintDtoAppResponse> {
        let url_ = this.baseUrl + "/api/v1/Lookups/system/complaint/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processComplaint4(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processComplaint4(<any>response_);
                } catch (e) {
                    return <Observable<SystemComplaintDtoAppResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<SystemComplaintDtoAppResponse>><any>_observableThrow(response_);
        }));
    }

    protected processComplaint4(response: HttpResponseBase): Observable<SystemComplaintDtoAppResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SystemComplaintDtoAppResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SystemComplaintDtoAppResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    status12(id: number, body?: ChangeLookupStatusInput | undefined): Observable<AppResponse> {
        let url_ = this.baseUrl + "/api/v1/Lookups/system/complaint/{id}/status";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStatus12(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStatus12(<any>response_);
                } catch (e) {
                    return <Observable<AppResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<AppResponse>><any>_observableThrow(response_);
        }));
    }

    protected processStatus12(response: HttpResponseBase): Observable<AppResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AppResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AppResponse>(<any>null);
    }
}

@Injectable()
export class SystemDiagnosisServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    diagnosis(body?: CreateSystemDiagnosisInput | undefined): Observable<Int64AppResponse> {
        let url_ = this.baseUrl + "/api/v1/Lookups/system/diagnosis";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDiagnosis(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDiagnosis(<any>response_);
                } catch (e) {
                    return <Observable<Int64AppResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<Int64AppResponse>><any>_observableThrow(response_);
        }));
    }

    protected processDiagnosis(response: HttpResponseBase): Observable<Int64AppResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Int64AppResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Int64AppResponse>(<any>null);
    }

    /**
     * @param deletedOnly (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    diagnosis2(deletedOnly?: boolean | undefined, skipCount?: number | undefined, maxResultCount?: number | undefined): Observable<SystemDiagnosisOutputAppResponse> {
        let url_ = this.baseUrl + "/api/v1/Lookups/system/diagnosis?";
        if (deletedOnly === null)
            throw new Error("The parameter 'deletedOnly' cannot be null.");
        else if (deletedOnly !== undefined)
            url_ += "DeletedOnly=" + encodeURIComponent("" + deletedOnly) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDiagnosis2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDiagnosis2(<any>response_);
                } catch (e) {
                    return <Observable<SystemDiagnosisOutputAppResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<SystemDiagnosisOutputAppResponse>><any>_observableThrow(response_);
        }));
    }

    protected processDiagnosis2(response: HttpResponseBase): Observable<SystemDiagnosisOutputAppResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SystemDiagnosisOutputAppResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SystemDiagnosisOutputAppResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    diagnosis3(id: number, body?: EditSystemDiagnosisInput | undefined): Observable<AppResponse> {
        let url_ = this.baseUrl + "/api/v1/Lookups/system/diagnosis/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDiagnosis3(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDiagnosis3(<any>response_);
                } catch (e) {
                    return <Observable<AppResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<AppResponse>><any>_observableThrow(response_);
        }));
    }

    protected processDiagnosis3(response: HttpResponseBase): Observable<AppResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AppResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AppResponse>(<any>null);
    }

    /**
     * @return Success
     */
    diagnosis4(id: number): Observable<SystemDiagnosisDtoAppResponse> {
        let url_ = this.baseUrl + "/api/v1/Lookups/system/diagnosis/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDiagnosis4(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDiagnosis4(<any>response_);
                } catch (e) {
                    return <Observable<SystemDiagnosisDtoAppResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<SystemDiagnosisDtoAppResponse>><any>_observableThrow(response_);
        }));
    }

    protected processDiagnosis4(response: HttpResponseBase): Observable<SystemDiagnosisDtoAppResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SystemDiagnosisDtoAppResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SystemDiagnosisDtoAppResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    status13(id: number, body?: ChangeLookupStatusInput | undefined): Observable<AppResponse> {
        let url_ = this.baseUrl + "/api/v1/Lookups/system/diagnosis/{id}/status";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStatus13(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStatus13(<any>response_);
                } catch (e) {
                    return <Observable<AppResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<AppResponse>><any>_observableThrow(response_);
        }));
    }

    protected processStatus13(response: HttpResponseBase): Observable<AppResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AppResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AppResponse>(<any>null);
    }
}

@Injectable()
export class SystemDiseaseServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    disease(body?: CreateSystemDiseaseInput | undefined): Observable<Int64AppResponse> {
        let url_ = this.baseUrl + "/api/v1/Lookups/system/disease";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDisease(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDisease(<any>response_);
                } catch (e) {
                    return <Observable<Int64AppResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<Int64AppResponse>><any>_observableThrow(response_);
        }));
    }

    protected processDisease(response: HttpResponseBase): Observable<Int64AppResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Int64AppResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Int64AppResponse>(<any>null);
    }

    /**
     * @param deletedOnly (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    disease2(deletedOnly?: boolean | undefined, skipCount?: number | undefined, maxResultCount?: number | undefined): Observable<SystemDiseasesOutputAppResponse> {
        let url_ = this.baseUrl + "/api/v1/Lookups/system/disease?";
        if (deletedOnly === null)
            throw new Error("The parameter 'deletedOnly' cannot be null.");
        else if (deletedOnly !== undefined)
            url_ += "DeletedOnly=" + encodeURIComponent("" + deletedOnly) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDisease2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDisease2(<any>response_);
                } catch (e) {
                    return <Observable<SystemDiseasesOutputAppResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<SystemDiseasesOutputAppResponse>><any>_observableThrow(response_);
        }));
    }

    protected processDisease2(response: HttpResponseBase): Observable<SystemDiseasesOutputAppResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SystemDiseasesOutputAppResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SystemDiseasesOutputAppResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    disease3(id: number, body?: EditSystemDiseaseInput | undefined): Observable<AppResponse> {
        let url_ = this.baseUrl + "/api/v1/Lookups/system/disease/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDisease3(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDisease3(<any>response_);
                } catch (e) {
                    return <Observable<AppResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<AppResponse>><any>_observableThrow(response_);
        }));
    }

    protected processDisease3(response: HttpResponseBase): Observable<AppResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AppResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AppResponse>(<any>null);
    }

    /**
     * @return Success
     */
    disease4(id: number): Observable<SystemDiseaseDtoAppResponse> {
        let url_ = this.baseUrl + "/api/v1/Lookups/system/disease/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDisease4(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDisease4(<any>response_);
                } catch (e) {
                    return <Observable<SystemDiseaseDtoAppResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<SystemDiseaseDtoAppResponse>><any>_observableThrow(response_);
        }));
    }

    protected processDisease4(response: HttpResponseBase): Observable<SystemDiseaseDtoAppResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SystemDiseaseDtoAppResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SystemDiseaseDtoAppResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    status14(id: number, body?: ChangeLookupStatusInput | undefined): Observable<AppResponse> {
        let url_ = this.baseUrl + "/api/v1/Lookups/system/disease/{id}/status";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStatus14(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStatus14(<any>response_);
                } catch (e) {
                    return <Observable<AppResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<AppResponse>><any>_observableThrow(response_);
        }));
    }

    protected processStatus14(response: HttpResponseBase): Observable<AppResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AppResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AppResponse>(<any>null);
    }
}

@Injectable()
export class SystemMedicalVisitProcedureServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    medicalVisitProcedure(body?: CreateSystemMedicalVisitProcedureInput | undefined): Observable<Int64AppResponse> {
        let url_ = this.baseUrl + "/api/v1/Lookups/system/medicalVisitProcedure";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMedicalVisitProcedure(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMedicalVisitProcedure(<any>response_);
                } catch (e) {
                    return <Observable<Int64AppResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<Int64AppResponse>><any>_observableThrow(response_);
        }));
    }

    protected processMedicalVisitProcedure(response: HttpResponseBase): Observable<Int64AppResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Int64AppResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Int64AppResponse>(<any>null);
    }

    /**
     * @param deletedOnly (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    medicalVisitProcedure2(deletedOnly?: boolean | undefined, skipCount?: number | undefined, maxResultCount?: number | undefined): Observable<SystemMedicalVisitProceduresOutputAppResponse> {
        let url_ = this.baseUrl + "/api/v1/Lookups/system/medicalVisitProcedure?";
        if (deletedOnly === null)
            throw new Error("The parameter 'deletedOnly' cannot be null.");
        else if (deletedOnly !== undefined)
            url_ += "DeletedOnly=" + encodeURIComponent("" + deletedOnly) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMedicalVisitProcedure2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMedicalVisitProcedure2(<any>response_);
                } catch (e) {
                    return <Observable<SystemMedicalVisitProceduresOutputAppResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<SystemMedicalVisitProceduresOutputAppResponse>><any>_observableThrow(response_);
        }));
    }

    protected processMedicalVisitProcedure2(response: HttpResponseBase): Observable<SystemMedicalVisitProceduresOutputAppResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SystemMedicalVisitProceduresOutputAppResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SystemMedicalVisitProceduresOutputAppResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    medicalVisitProcedure3(id: number, body?: EditSystemMedicalVisitProcedureInput | undefined): Observable<AppResponse> {
        let url_ = this.baseUrl + "/api/v1/Lookups/system/medicalVisitProcedure/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMedicalVisitProcedure3(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMedicalVisitProcedure3(<any>response_);
                } catch (e) {
                    return <Observable<AppResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<AppResponse>><any>_observableThrow(response_);
        }));
    }

    protected processMedicalVisitProcedure3(response: HttpResponseBase): Observable<AppResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AppResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AppResponse>(<any>null);
    }

    /**
     * @return Success
     */
    medicalVisitProcedure4(id: number): Observable<SystemMedicalVisitProcedureDtoAppResponse> {
        let url_ = this.baseUrl + "/api/v1/Lookups/system/medicalVisitProcedure/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMedicalVisitProcedure4(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMedicalVisitProcedure4(<any>response_);
                } catch (e) {
                    return <Observable<SystemMedicalVisitProcedureDtoAppResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<SystemMedicalVisitProcedureDtoAppResponse>><any>_observableThrow(response_);
        }));
    }

    protected processMedicalVisitProcedure4(response: HttpResponseBase): Observable<SystemMedicalVisitProcedureDtoAppResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SystemMedicalVisitProcedureDtoAppResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SystemMedicalVisitProcedureDtoAppResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    status15(id: number, body?: ChangeLookupStatusInput | undefined): Observable<AppResponse> {
        let url_ = this.baseUrl + "/api/v1/Lookups/system/medicalVisitProcedure/{id}/status";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStatus15(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStatus15(<any>response_);
                } catch (e) {
                    return <Observable<AppResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<AppResponse>><any>_observableThrow(response_);
        }));
    }

    protected processStatus15(response: HttpResponseBase): Observable<AppResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AppResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AppResponse>(<any>null);
    }
}

@Injectable()
export class SystemSurgeryServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    surgery(body?: CreateSystemSurgeryInput | undefined): Observable<Int64AppResponse> {
        let url_ = this.baseUrl + "/api/v1/Lookups/system/surgery";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSurgery(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSurgery(<any>response_);
                } catch (e) {
                    return <Observable<Int64AppResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<Int64AppResponse>><any>_observableThrow(response_);
        }));
    }

    protected processSurgery(response: HttpResponseBase): Observable<Int64AppResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Int64AppResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Int64AppResponse>(<any>null);
    }

    /**
     * @param deletedOnly (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    surgery2(deletedOnly?: boolean | undefined, skipCount?: number | undefined, maxResultCount?: number | undefined): Observable<SystemSurgeriesOutputAppResponse> {
        let url_ = this.baseUrl + "/api/v1/Lookups/system/surgery?";
        if (deletedOnly === null)
            throw new Error("The parameter 'deletedOnly' cannot be null.");
        else if (deletedOnly !== undefined)
            url_ += "DeletedOnly=" + encodeURIComponent("" + deletedOnly) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSurgery2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSurgery2(<any>response_);
                } catch (e) {
                    return <Observable<SystemSurgeriesOutputAppResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<SystemSurgeriesOutputAppResponse>><any>_observableThrow(response_);
        }));
    }

    protected processSurgery2(response: HttpResponseBase): Observable<SystemSurgeriesOutputAppResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SystemSurgeriesOutputAppResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SystemSurgeriesOutputAppResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    surgery3(id: number, body?: EditSystemSurgeryInput | undefined): Observable<AppResponse> {
        let url_ = this.baseUrl + "/api/v1/Lookups/system/surgery/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSurgery3(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSurgery3(<any>response_);
                } catch (e) {
                    return <Observable<AppResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<AppResponse>><any>_observableThrow(response_);
        }));
    }

    protected processSurgery3(response: HttpResponseBase): Observable<AppResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AppResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AppResponse>(<any>null);
    }

    /**
     * @return Success
     */
    surgery4(id: number): Observable<SystemSurgeryDtoAppResponse> {
        let url_ = this.baseUrl + "/api/v1/Lookups/system/surgery/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSurgery4(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSurgery4(<any>response_);
                } catch (e) {
                    return <Observable<SystemSurgeryDtoAppResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<SystemSurgeryDtoAppResponse>><any>_observableThrow(response_);
        }));
    }

    protected processSurgery4(response: HttpResponseBase): Observable<SystemSurgeryDtoAppResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SystemSurgeryDtoAppResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SystemSurgeryDtoAppResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    status16(id: number, body?: ChangeLookupStatusInput | undefined): Observable<AppResponse> {
        let url_ = this.baseUrl + "/api/v1/Lookups/system/surgery/{id}/status";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStatus16(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStatus16(<any>response_);
                } catch (e) {
                    return <Observable<AppResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<AppResponse>><any>_observableThrow(response_);
        }));
    }

    protected processStatus16(response: HttpResponseBase): Observable<AppResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AppResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AppResponse>(<any>null);
    }
}

@Injectable()
export class SystemSurgeryProcedureServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    surgeryProcedure(body?: CreateSystemSurgeryProcedureInput | undefined): Observable<Int64AppResponse> {
        let url_ = this.baseUrl + "/api/v1/Lookups/system/surgeryProcedure";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSurgeryProcedure(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSurgeryProcedure(<any>response_);
                } catch (e) {
                    return <Observable<Int64AppResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<Int64AppResponse>><any>_observableThrow(response_);
        }));
    }

    protected processSurgeryProcedure(response: HttpResponseBase): Observable<Int64AppResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Int64AppResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Int64AppResponse>(<any>null);
    }

    /**
     * @param deletedOnly (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    surgeryProcedure2(deletedOnly?: boolean | undefined, skipCount?: number | undefined, maxResultCount?: number | undefined): Observable<SystemSurgeryProceduresOutputAppResponse> {
        let url_ = this.baseUrl + "/api/v1/Lookups/system/surgeryProcedure?";
        if (deletedOnly === null)
            throw new Error("The parameter 'deletedOnly' cannot be null.");
        else if (deletedOnly !== undefined)
            url_ += "DeletedOnly=" + encodeURIComponent("" + deletedOnly) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSurgeryProcedure2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSurgeryProcedure2(<any>response_);
                } catch (e) {
                    return <Observable<SystemSurgeryProceduresOutputAppResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<SystemSurgeryProceduresOutputAppResponse>><any>_observableThrow(response_);
        }));
    }

    protected processSurgeryProcedure2(response: HttpResponseBase): Observable<SystemSurgeryProceduresOutputAppResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SystemSurgeryProceduresOutputAppResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SystemSurgeryProceduresOutputAppResponse>(<any>null);
    }

    /**
     * @return Success
     */
    surgeryProcedure3(id: number): Observable<SystemSurgeryProcedureDtoAppResponse> {
        let url_ = this.baseUrl + "/api/v1/Lookups/system/surgeryProcedure/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSurgeryProcedure3(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSurgeryProcedure3(<any>response_);
                } catch (e) {
                    return <Observable<SystemSurgeryProcedureDtoAppResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<SystemSurgeryProcedureDtoAppResponse>><any>_observableThrow(response_);
        }));
    }

    protected processSurgeryProcedure3(response: HttpResponseBase): Observable<SystemSurgeryProcedureDtoAppResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SystemSurgeryProcedureDtoAppResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SystemSurgeryProcedureDtoAppResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    surgeryProcedure4(id: number, body?: EditSystemSurgeryProcedureInput | undefined): Observable<AppResponse> {
        let url_ = this.baseUrl + "/api/v1/Lookups/system/surgeryProcedure/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSurgeryProcedure4(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSurgeryProcedure4(<any>response_);
                } catch (e) {
                    return <Observable<AppResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<AppResponse>><any>_observableThrow(response_);
        }));
    }

    protected processSurgeryProcedure4(response: HttpResponseBase): Observable<AppResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AppResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AppResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    status17(id: number, body?: ChangeLookupStatusInput | undefined): Observable<AppResponse> {
        let url_ = this.baseUrl + "/api/v1/Lookups/system/surgeryProcedure/{id}/status";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStatus17(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStatus17(<any>response_);
                } catch (e) {
                    return <Observable<AppResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<AppResponse>><any>_observableThrow(response_);
        }));
    }

    protected processStatus17(response: HttpResponseBase): Observable<AppResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AppResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Unauthorized", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Forbidden", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AppResponse>(<any>null);
    }
}

export class TokenRequest implements ITokenRequest {
    username!: string;
    password!: string;

    constructor(data?: ITokenRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.username = _data["username"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): TokenRequest {
        data = typeof data === 'object' ? data : {};
        let result = new TokenRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["username"] = this.username;
        data["password"] = this.password;
        return data; 
    }

    clone(): TokenRequest {
        const json = this.toJSON();
        let result = new TokenRequest();
        result.init(json);
        return result;
    }
}

export interface ITokenRequest {
    username: string;
    password: string;
}

export class TokenDto implements ITokenDto {
    token!: string | undefined;
    userId!: number;

    constructor(data?: ITokenDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.token = _data["token"];
            this.userId = _data["userId"];
        }
    }

    static fromJS(data: any): TokenDto {
        data = typeof data === 'object' ? data : {};
        let result = new TokenDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["token"] = this.token;
        data["userId"] = this.userId;
        return data; 
    }

    clone(): TokenDto {
        const json = this.toJSON();
        let result = new TokenDto();
        result.init(json);
        return result;
    }
}

export interface ITokenDto {
    token: string | undefined;
    userId: number;
}

export class TokenDtoAppResponse implements ITokenDtoAppResponse {
    data!: TokenDto;
    isSuccessful!: boolean;
    statusCode!: string | undefined;
    statusDescription!: string | undefined;

    constructor(data?: ITokenDtoAppResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? TokenDto.fromJS(_data["data"]) : <any>undefined;
            this.isSuccessful = _data["isSuccessful"];
            this.statusCode = _data["statusCode"];
            this.statusDescription = _data["statusDescription"];
        }
    }

    static fromJS(data: any): TokenDtoAppResponse {
        data = typeof data === 'object' ? data : {};
        let result = new TokenDtoAppResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["isSuccessful"] = this.isSuccessful;
        data["statusCode"] = this.statusCode;
        data["statusDescription"] = this.statusDescription;
        return data; 
    }

    clone(): TokenDtoAppResponse {
        const json = this.toJSON();
        let result = new TokenDtoAppResponse();
        result.init(json);
        return result;
    }
}

export interface ITokenDtoAppResponse {
    data: TokenDto;
    isSuccessful: boolean;
    statusCode: string | undefined;
    statusDescription: string | undefined;
}

export class CreateAllergicInput implements ICreateAllergicInput {
    name!: string;

    constructor(data?: ICreateAllergicInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): CreateAllergicInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateAllergicInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data; 
    }

    clone(): CreateAllergicInput {
        const json = this.toJSON();
        let result = new CreateAllergicInput();
        result.init(json);
        return result;
    }
}

export interface ICreateAllergicInput {
    name: string;
}

export class Int64AppResponse implements IInt64AppResponse {
    data!: number;
    isSuccessful!: boolean;
    statusCode!: string | undefined;
    statusDescription!: string | undefined;

    constructor(data?: IInt64AppResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"];
            this.isSuccessful = _data["isSuccessful"];
            this.statusCode = _data["statusCode"];
            this.statusDescription = _data["statusDescription"];
        }
    }

    static fromJS(data: any): Int64AppResponse {
        data = typeof data === 'object' ? data : {};
        let result = new Int64AppResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data;
        data["isSuccessful"] = this.isSuccessful;
        data["statusCode"] = this.statusCode;
        data["statusDescription"] = this.statusDescription;
        return data; 
    }

    clone(): Int64AppResponse {
        const json = this.toJSON();
        let result = new Int64AppResponse();
        result.init(json);
        return result;
    }
}

export interface IInt64AppResponse {
    data: number;
    isSuccessful: boolean;
    statusCode: string | undefined;
    statusDescription: string | undefined;
}

export enum LookupStatus {
    _1 = 1,
    _2 = 2,
}

export class LookupDto implements ILookupDto {
    id!: number;
    status!: LookupStatus;
    name!: string | undefined;

    constructor(data?: ILookupDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.status = _data["status"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): LookupDto {
        data = typeof data === 'object' ? data : {};
        let result = new LookupDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["status"] = this.status;
        data["name"] = this.name;
        return data; 
    }

    clone(): LookupDto {
        const json = this.toJSON();
        let result = new LookupDto();
        result.init(json);
        return result;
    }
}

export interface ILookupDto {
    id: number;
    status: LookupStatus;
    name: string | undefined;
}

export class AllergiesOutput implements IAllergiesOutput {
    allergies!: LookupDto[] | undefined;

    constructor(data?: IAllergiesOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["allergies"])) {
                this.allergies = [] as any;
                for (let item of _data["allergies"])
                    this.allergies!.push(LookupDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AllergiesOutput {
        data = typeof data === 'object' ? data : {};
        let result = new AllergiesOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.allergies)) {
            data["allergies"] = [];
            for (let item of this.allergies)
                data["allergies"].push(item.toJSON());
        }
        return data; 
    }

    clone(): AllergiesOutput {
        const json = this.toJSON();
        let result = new AllergiesOutput();
        result.init(json);
        return result;
    }
}

export interface IAllergiesOutput {
    allergies: LookupDto[] | undefined;
}

export class AllergiesOutputAppResponse implements IAllergiesOutputAppResponse {
    data!: AllergiesOutput;
    isSuccessful!: boolean;
    statusCode!: string | undefined;
    statusDescription!: string | undefined;

    constructor(data?: IAllergiesOutputAppResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? AllergiesOutput.fromJS(_data["data"]) : <any>undefined;
            this.isSuccessful = _data["isSuccessful"];
            this.statusCode = _data["statusCode"];
            this.statusDescription = _data["statusDescription"];
        }
    }

    static fromJS(data: any): AllergiesOutputAppResponse {
        data = typeof data === 'object' ? data : {};
        let result = new AllergiesOutputAppResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["isSuccessful"] = this.isSuccessful;
        data["statusCode"] = this.statusCode;
        data["statusDescription"] = this.statusDescription;
        return data; 
    }

    clone(): AllergiesOutputAppResponse {
        const json = this.toJSON();
        let result = new AllergiesOutputAppResponse();
        result.init(json);
        return result;
    }
}

export interface IAllergiesOutputAppResponse {
    data: AllergiesOutput;
    isSuccessful: boolean;
    statusCode: string | undefined;
    statusDescription: string | undefined;
}

export class EditAllergicInput implements IEditAllergicInput {
    name!: string;

    constructor(data?: IEditAllergicInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): EditAllergicInput {
        data = typeof data === 'object' ? data : {};
        let result = new EditAllergicInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data; 
    }

    clone(): EditAllergicInput {
        const json = this.toJSON();
        let result = new EditAllergicInput();
        result.init(json);
        return result;
    }
}

export interface IEditAllergicInput {
    name: string;
}

export class AppResponse implements IAppResponse {
    isSuccessful!: boolean;
    statusCode!: string | undefined;
    statusDescription!: string | undefined;

    constructor(data?: IAppResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccessful = _data["isSuccessful"];
            this.statusCode = _data["statusCode"];
            this.statusDescription = _data["statusDescription"];
        }
    }

    static fromJS(data: any): AppResponse {
        data = typeof data === 'object' ? data : {};
        let result = new AppResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccessful"] = this.isSuccessful;
        data["statusCode"] = this.statusCode;
        data["statusDescription"] = this.statusDescription;
        return data; 
    }

    clone(): AppResponse {
        const json = this.toJSON();
        let result = new AppResponse();
        result.init(json);
        return result;
    }
}

export interface IAppResponse {
    isSuccessful: boolean;
    statusCode: string | undefined;
    statusDescription: string | undefined;
}

export class LookupDtoAppResponse implements ILookupDtoAppResponse {
    data!: LookupDto;
    isSuccessful!: boolean;
    statusCode!: string | undefined;
    statusDescription!: string | undefined;

    constructor(data?: ILookupDtoAppResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? LookupDto.fromJS(_data["data"]) : <any>undefined;
            this.isSuccessful = _data["isSuccessful"];
            this.statusCode = _data["statusCode"];
            this.statusDescription = _data["statusDescription"];
        }
    }

    static fromJS(data: any): LookupDtoAppResponse {
        data = typeof data === 'object' ? data : {};
        let result = new LookupDtoAppResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["isSuccessful"] = this.isSuccessful;
        data["statusCode"] = this.statusCode;
        data["statusDescription"] = this.statusDescription;
        return data; 
    }

    clone(): LookupDtoAppResponse {
        const json = this.toJSON();
        let result = new LookupDtoAppResponse();
        result.init(json);
        return result;
    }
}

export interface ILookupDtoAppResponse {
    data: LookupDto;
    isSuccessful: boolean;
    statusCode: string | undefined;
    statusDescription: string | undefined;
}

export class ChangeLookupStatusInput implements IChangeLookupStatusInput {
    status!: LookupStatus;

    constructor(data?: IChangeLookupStatusInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): ChangeLookupStatusInput {
        data = typeof data === 'object' ? data : {};
        let result = new ChangeLookupStatusInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        return data; 
    }

    clone(): ChangeLookupStatusInput {
        const json = this.toJSON();
        let result = new ChangeLookupStatusInput();
        result.init(json);
        return result;
    }
}

export interface IChangeLookupStatusInput {
    status: LookupStatus;
}

export class CreateBankInput implements ICreateBankInput {
    name!: string;

    constructor(data?: ICreateBankInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): CreateBankInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateBankInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data; 
    }

    clone(): CreateBankInput {
        const json = this.toJSON();
        let result = new CreateBankInput();
        result.init(json);
        return result;
    }
}

export interface ICreateBankInput {
    name: string;
}

export class BanksOutput implements IBanksOutput {
    banks!: LookupDto[] | undefined;

    constructor(data?: IBanksOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["banks"])) {
                this.banks = [] as any;
                for (let item of _data["banks"])
                    this.banks!.push(LookupDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): BanksOutput {
        data = typeof data === 'object' ? data : {};
        let result = new BanksOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.banks)) {
            data["banks"] = [];
            for (let item of this.banks)
                data["banks"].push(item.toJSON());
        }
        return data; 
    }

    clone(): BanksOutput {
        const json = this.toJSON();
        let result = new BanksOutput();
        result.init(json);
        return result;
    }
}

export interface IBanksOutput {
    banks: LookupDto[] | undefined;
}

export class BanksOutputAppResponse implements IBanksOutputAppResponse {
    data!: BanksOutput;
    isSuccessful!: boolean;
    statusCode!: string | undefined;
    statusDescription!: string | undefined;

    constructor(data?: IBanksOutputAppResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? BanksOutput.fromJS(_data["data"]) : <any>undefined;
            this.isSuccessful = _data["isSuccessful"];
            this.statusCode = _data["statusCode"];
            this.statusDescription = _data["statusDescription"];
        }
    }

    static fromJS(data: any): BanksOutputAppResponse {
        data = typeof data === 'object' ? data : {};
        let result = new BanksOutputAppResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["isSuccessful"] = this.isSuccessful;
        data["statusCode"] = this.statusCode;
        data["statusDescription"] = this.statusDescription;
        return data; 
    }

    clone(): BanksOutputAppResponse {
        const json = this.toJSON();
        let result = new BanksOutputAppResponse();
        result.init(json);
        return result;
    }
}

export interface IBanksOutputAppResponse {
    data: BanksOutput;
    isSuccessful: boolean;
    statusCode: string | undefined;
    statusDescription: string | undefined;
}

export class EditBankInput implements IEditBankInput {
    name!: string;

    constructor(data?: IEditBankInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): EditBankInput {
        data = typeof data === 'object' ? data : {};
        let result = new EditBankInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data; 
    }

    clone(): EditBankInput {
        const json = this.toJSON();
        let result = new EditBankInput();
        result.init(json);
        return result;
    }
}

export interface IEditBankInput {
    name: string;
}

export class CreateComplaintInput implements ICreateComplaintInput {
    name!: string;

    constructor(data?: ICreateComplaintInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): CreateComplaintInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateComplaintInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data; 
    }

    clone(): CreateComplaintInput {
        const json = this.toJSON();
        let result = new CreateComplaintInput();
        result.init(json);
        return result;
    }
}

export interface ICreateComplaintInput {
    name: string;
}

export class EditComplaintInput implements IEditComplaintInput {
    name!: string;

    constructor(data?: IEditComplaintInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): EditComplaintInput {
        data = typeof data === 'object' ? data : {};
        let result = new EditComplaintInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data; 
    }

    clone(): EditComplaintInput {
        const json = this.toJSON();
        let result = new EditComplaintInput();
        result.init(json);
        return result;
    }
}

export interface IEditComplaintInput {
    name: string;
}

export class CreateDiagnosisInput implements ICreateDiagnosisInput {
    name!: string;

    constructor(data?: ICreateDiagnosisInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): CreateDiagnosisInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateDiagnosisInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data; 
    }

    clone(): CreateDiagnosisInput {
        const json = this.toJSON();
        let result = new CreateDiagnosisInput();
        result.init(json);
        return result;
    }
}

export interface ICreateDiagnosisInput {
    name: string;
}

export class DiagnosisOutput implements IDiagnosisOutput {
    diagnoses!: LookupDto[] | undefined;

    constructor(data?: IDiagnosisOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["diagnoses"])) {
                this.diagnoses = [] as any;
                for (let item of _data["diagnoses"])
                    this.diagnoses!.push(LookupDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DiagnosisOutput {
        data = typeof data === 'object' ? data : {};
        let result = new DiagnosisOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.diagnoses)) {
            data["diagnoses"] = [];
            for (let item of this.diagnoses)
                data["diagnoses"].push(item.toJSON());
        }
        return data; 
    }

    clone(): DiagnosisOutput {
        const json = this.toJSON();
        let result = new DiagnosisOutput();
        result.init(json);
        return result;
    }
}

export interface IDiagnosisOutput {
    diagnoses: LookupDto[] | undefined;
}

export class DiagnosisOutputAppResponse implements IDiagnosisOutputAppResponse {
    data!: DiagnosisOutput;
    isSuccessful!: boolean;
    statusCode!: string | undefined;
    statusDescription!: string | undefined;

    constructor(data?: IDiagnosisOutputAppResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? DiagnosisOutput.fromJS(_data["data"]) : <any>undefined;
            this.isSuccessful = _data["isSuccessful"];
            this.statusCode = _data["statusCode"];
            this.statusDescription = _data["statusDescription"];
        }
    }

    static fromJS(data: any): DiagnosisOutputAppResponse {
        data = typeof data === 'object' ? data : {};
        let result = new DiagnosisOutputAppResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["isSuccessful"] = this.isSuccessful;
        data["statusCode"] = this.statusCode;
        data["statusDescription"] = this.statusDescription;
        return data; 
    }

    clone(): DiagnosisOutputAppResponse {
        const json = this.toJSON();
        let result = new DiagnosisOutputAppResponse();
        result.init(json);
        return result;
    }
}

export interface IDiagnosisOutputAppResponse {
    data: DiagnosisOutput;
    isSuccessful: boolean;
    statusCode: string | undefined;
    statusDescription: string | undefined;
}

export class EditDiagnosisInput implements IEditDiagnosisInput {
    name!: string;

    constructor(data?: IEditDiagnosisInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): EditDiagnosisInput {
        data = typeof data === 'object' ? data : {};
        let result = new EditDiagnosisInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data; 
    }

    clone(): EditDiagnosisInput {
        const json = this.toJSON();
        let result = new EditDiagnosisInput();
        result.init(json);
        return result;
    }
}

export interface IEditDiagnosisInput {
    name: string;
}

export class CreateDiseaseInput implements ICreateDiseaseInput {
    name!: string;

    constructor(data?: ICreateDiseaseInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): CreateDiseaseInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateDiseaseInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data; 
    }

    clone(): CreateDiseaseInput {
        const json = this.toJSON();
        let result = new CreateDiseaseInput();
        result.init(json);
        return result;
    }
}

export interface ICreateDiseaseInput {
    name: string;
}

export class DiseasesOutput implements IDiseasesOutput {
    diseases!: LookupDto[] | undefined;

    constructor(data?: IDiseasesOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["diseases"])) {
                this.diseases = [] as any;
                for (let item of _data["diseases"])
                    this.diseases!.push(LookupDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DiseasesOutput {
        data = typeof data === 'object' ? data : {};
        let result = new DiseasesOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.diseases)) {
            data["diseases"] = [];
            for (let item of this.diseases)
                data["diseases"].push(item.toJSON());
        }
        return data; 
    }

    clone(): DiseasesOutput {
        const json = this.toJSON();
        let result = new DiseasesOutput();
        result.init(json);
        return result;
    }
}

export interface IDiseasesOutput {
    diseases: LookupDto[] | undefined;
}

export class DiseasesOutputAppResponse implements IDiseasesOutputAppResponse {
    data!: DiseasesOutput;
    isSuccessful!: boolean;
    statusCode!: string | undefined;
    statusDescription!: string | undefined;

    constructor(data?: IDiseasesOutputAppResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? DiseasesOutput.fromJS(_data["data"]) : <any>undefined;
            this.isSuccessful = _data["isSuccessful"];
            this.statusCode = _data["statusCode"];
            this.statusDescription = _data["statusDescription"];
        }
    }

    static fromJS(data: any): DiseasesOutputAppResponse {
        data = typeof data === 'object' ? data : {};
        let result = new DiseasesOutputAppResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["isSuccessful"] = this.isSuccessful;
        data["statusCode"] = this.statusCode;
        data["statusDescription"] = this.statusDescription;
        return data; 
    }

    clone(): DiseasesOutputAppResponse {
        const json = this.toJSON();
        let result = new DiseasesOutputAppResponse();
        result.init(json);
        return result;
    }
}

export interface IDiseasesOutputAppResponse {
    data: DiseasesOutput;
    isSuccessful: boolean;
    statusCode: string | undefined;
    statusDescription: string | undefined;
}

export class EditDiseaseInput implements IEditDiseaseInput {
    name!: string;

    constructor(data?: IEditDiseaseInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): EditDiseaseInput {
        data = typeof data === 'object' ? data : {};
        let result = new EditDiseaseInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data; 
    }

    clone(): EditDiseaseInput {
        const json = this.toJSON();
        let result = new EditDiseaseInput();
        result.init(json);
        return result;
    }
}

export interface IEditDiseaseInput {
    name: string;
}

export class CreateMedicalVisitProcedureInput implements ICreateMedicalVisitProcedureInput {
    name!: string;

    constructor(data?: ICreateMedicalVisitProcedureInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): CreateMedicalVisitProcedureInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateMedicalVisitProcedureInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data; 
    }

    clone(): CreateMedicalVisitProcedureInput {
        const json = this.toJSON();
        let result = new CreateMedicalVisitProcedureInput();
        result.init(json);
        return result;
    }
}

export interface ICreateMedicalVisitProcedureInput {
    name: string;
}

export class MedicalVisitProceduresOutput implements IMedicalVisitProceduresOutput {
    medicalVisitProcedures!: LookupDto[] | undefined;

    constructor(data?: IMedicalVisitProceduresOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["medicalVisitProcedures"])) {
                this.medicalVisitProcedures = [] as any;
                for (let item of _data["medicalVisitProcedures"])
                    this.medicalVisitProcedures!.push(LookupDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): MedicalVisitProceduresOutput {
        data = typeof data === 'object' ? data : {};
        let result = new MedicalVisitProceduresOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.medicalVisitProcedures)) {
            data["medicalVisitProcedures"] = [];
            for (let item of this.medicalVisitProcedures)
                data["medicalVisitProcedures"].push(item.toJSON());
        }
        return data; 
    }

    clone(): MedicalVisitProceduresOutput {
        const json = this.toJSON();
        let result = new MedicalVisitProceduresOutput();
        result.init(json);
        return result;
    }
}

export interface IMedicalVisitProceduresOutput {
    medicalVisitProcedures: LookupDto[] | undefined;
}

export class MedicalVisitProceduresOutputAppResponse implements IMedicalVisitProceduresOutputAppResponse {
    data!: MedicalVisitProceduresOutput;
    isSuccessful!: boolean;
    statusCode!: string | undefined;
    statusDescription!: string | undefined;

    constructor(data?: IMedicalVisitProceduresOutputAppResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? MedicalVisitProceduresOutput.fromJS(_data["data"]) : <any>undefined;
            this.isSuccessful = _data["isSuccessful"];
            this.statusCode = _data["statusCode"];
            this.statusDescription = _data["statusDescription"];
        }
    }

    static fromJS(data: any): MedicalVisitProceduresOutputAppResponse {
        data = typeof data === 'object' ? data : {};
        let result = new MedicalVisitProceduresOutputAppResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["isSuccessful"] = this.isSuccessful;
        data["statusCode"] = this.statusCode;
        data["statusDescription"] = this.statusDescription;
        return data; 
    }

    clone(): MedicalVisitProceduresOutputAppResponse {
        const json = this.toJSON();
        let result = new MedicalVisitProceduresOutputAppResponse();
        result.init(json);
        return result;
    }
}

export interface IMedicalVisitProceduresOutputAppResponse {
    data: MedicalVisitProceduresOutput;
    isSuccessful: boolean;
    statusCode: string | undefined;
    statusDescription: string | undefined;
}

export class EditMedicalVisitProcedureInput implements IEditMedicalVisitProcedureInput {
    name!: string;

    constructor(data?: IEditMedicalVisitProcedureInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): EditMedicalVisitProcedureInput {
        data = typeof data === 'object' ? data : {};
        let result = new EditMedicalVisitProcedureInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data; 
    }

    clone(): EditMedicalVisitProcedureInput {
        const json = this.toJSON();
        let result = new EditMedicalVisitProcedureInput();
        result.init(json);
        return result;
    }
}

export interface IEditMedicalVisitProcedureInput {
    name: string;
}

export class CreateSurgeryInput implements ICreateSurgeryInput {
    surgeriesProceduresIds!: number[] | undefined;
    name!: string;

    constructor(data?: ICreateSurgeryInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["surgeriesProceduresIds"])) {
                this.surgeriesProceduresIds = [] as any;
                for (let item of _data["surgeriesProceduresIds"])
                    this.surgeriesProceduresIds!.push(item);
            }
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): CreateSurgeryInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateSurgeryInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.surgeriesProceduresIds)) {
            data["surgeriesProceduresIds"] = [];
            for (let item of this.surgeriesProceduresIds)
                data["surgeriesProceduresIds"].push(item);
        }
        data["name"] = this.name;
        return data; 
    }

    clone(): CreateSurgeryInput {
        const json = this.toJSON();
        let result = new CreateSurgeryInput();
        result.init(json);
        return result;
    }
}

export interface ICreateSurgeryInput {
    surgeriesProceduresIds: number[] | undefined;
    name: string;
}

export class SurgeriesOutput implements ISurgeriesOutput {
    surgeries!: LookupDto[] | undefined;

    constructor(data?: ISurgeriesOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["surgeries"])) {
                this.surgeries = [] as any;
                for (let item of _data["surgeries"])
                    this.surgeries!.push(LookupDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SurgeriesOutput {
        data = typeof data === 'object' ? data : {};
        let result = new SurgeriesOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.surgeries)) {
            data["surgeries"] = [];
            for (let item of this.surgeries)
                data["surgeries"].push(item.toJSON());
        }
        return data; 
    }

    clone(): SurgeriesOutput {
        const json = this.toJSON();
        let result = new SurgeriesOutput();
        result.init(json);
        return result;
    }
}

export interface ISurgeriesOutput {
    surgeries: LookupDto[] | undefined;
}

export class SurgeriesOutputAppResponse implements ISurgeriesOutputAppResponse {
    data!: SurgeriesOutput;
    isSuccessful!: boolean;
    statusCode!: string | undefined;
    statusDescription!: string | undefined;

    constructor(data?: ISurgeriesOutputAppResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? SurgeriesOutput.fromJS(_data["data"]) : <any>undefined;
            this.isSuccessful = _data["isSuccessful"];
            this.statusCode = _data["statusCode"];
            this.statusDescription = _data["statusDescription"];
        }
    }

    static fromJS(data: any): SurgeriesOutputAppResponse {
        data = typeof data === 'object' ? data : {};
        let result = new SurgeriesOutputAppResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["isSuccessful"] = this.isSuccessful;
        data["statusCode"] = this.statusCode;
        data["statusDescription"] = this.statusDescription;
        return data; 
    }

    clone(): SurgeriesOutputAppResponse {
        const json = this.toJSON();
        let result = new SurgeriesOutputAppResponse();
        result.init(json);
        return result;
    }
}

export interface ISurgeriesOutputAppResponse {
    data: SurgeriesOutput;
    isSuccessful: boolean;
    statusCode: string | undefined;
    statusDescription: string | undefined;
}

export class EditSurgeryInput implements IEditSurgeryInput {
    surgeriesProceduresIds!: number[] | undefined;
    name!: string;

    constructor(data?: IEditSurgeryInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["surgeriesProceduresIds"])) {
                this.surgeriesProceduresIds = [] as any;
                for (let item of _data["surgeriesProceduresIds"])
                    this.surgeriesProceduresIds!.push(item);
            }
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): EditSurgeryInput {
        data = typeof data === 'object' ? data : {};
        let result = new EditSurgeryInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.surgeriesProceduresIds)) {
            data["surgeriesProceduresIds"] = [];
            for (let item of this.surgeriesProceduresIds)
                data["surgeriesProceduresIds"].push(item);
        }
        data["name"] = this.name;
        return data; 
    }

    clone(): EditSurgeryInput {
        const json = this.toJSON();
        let result = new EditSurgeryInput();
        result.init(json);
        return result;
    }
}

export interface IEditSurgeryInput {
    surgeriesProceduresIds: number[] | undefined;
    name: string;
}

export class SurgeryProcedureDto implements ISurgeryProcedureDto {
    id!: number;
    points!: number;
    number!: number;

    constructor(data?: ISurgeryProcedureDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.points = _data["points"];
            this.number = _data["number"];
        }
    }

    static fromJS(data: any): SurgeryProcedureDto {
        data = typeof data === 'object' ? data : {};
        let result = new SurgeryProcedureDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["points"] = this.points;
        data["number"] = this.number;
        return data; 
    }

    clone(): SurgeryProcedureDto {
        const json = this.toJSON();
        let result = new SurgeryProcedureDto();
        result.init(json);
        return result;
    }
}

export interface ISurgeryProcedureDto {
    id: number;
    points: number;
    number: number;
}

export class SurgeryDto implements ISurgeryDto {
    id!: number;
    name!: string | undefined;
    surgeriesProcedures!: SurgeryProcedureDto[] | undefined;

    constructor(data?: ISurgeryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            if (Array.isArray(_data["surgeriesProcedures"])) {
                this.surgeriesProcedures = [] as any;
                for (let item of _data["surgeriesProcedures"])
                    this.surgeriesProcedures!.push(SurgeryProcedureDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SurgeryDto {
        data = typeof data === 'object' ? data : {};
        let result = new SurgeryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        if (Array.isArray(this.surgeriesProcedures)) {
            data["surgeriesProcedures"] = [];
            for (let item of this.surgeriesProcedures)
                data["surgeriesProcedures"].push(item.toJSON());
        }
        return data; 
    }

    clone(): SurgeryDto {
        const json = this.toJSON();
        let result = new SurgeryDto();
        result.init(json);
        return result;
    }
}

export interface ISurgeryDto {
    id: number;
    name: string | undefined;
    surgeriesProcedures: SurgeryProcedureDto[] | undefined;
}

export class SurgeryDtoAppResponse implements ISurgeryDtoAppResponse {
    data!: SurgeryDto;
    isSuccessful!: boolean;
    statusCode!: string | undefined;
    statusDescription!: string | undefined;

    constructor(data?: ISurgeryDtoAppResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? SurgeryDto.fromJS(_data["data"]) : <any>undefined;
            this.isSuccessful = _data["isSuccessful"];
            this.statusCode = _data["statusCode"];
            this.statusDescription = _data["statusDescription"];
        }
    }

    static fromJS(data: any): SurgeryDtoAppResponse {
        data = typeof data === 'object' ? data : {};
        let result = new SurgeryDtoAppResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["isSuccessful"] = this.isSuccessful;
        data["statusCode"] = this.statusCode;
        data["statusDescription"] = this.statusDescription;
        return data; 
    }

    clone(): SurgeryDtoAppResponse {
        const json = this.toJSON();
        let result = new SurgeryDtoAppResponse();
        result.init(json);
        return result;
    }
}

export interface ISurgeryDtoAppResponse {
    data: SurgeryDto;
    isSuccessful: boolean;
    statusCode: string | undefined;
    statusDescription: string | undefined;
}

export class CreateSurgeryProcedureInput implements ICreateSurgeryProcedureInput {
    points!: number;
    number!: string | undefined;
    name!: string;

    constructor(data?: ICreateSurgeryProcedureInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.points = _data["points"];
            this.number = _data["number"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): CreateSurgeryProcedureInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateSurgeryProcedureInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["points"] = this.points;
        data["number"] = this.number;
        data["name"] = this.name;
        return data; 
    }

    clone(): CreateSurgeryProcedureInput {
        const json = this.toJSON();
        let result = new CreateSurgeryProcedureInput();
        result.init(json);
        return result;
    }
}

export interface ICreateSurgeryProcedureInput {
    points: number;
    number: string | undefined;
    name: string;
}

export class SurgeryProceduresOutput implements ISurgeryProceduresOutput {
    surgeryProcedures!: LookupDto[] | undefined;

    constructor(data?: ISurgeryProceduresOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["surgeryProcedures"])) {
                this.surgeryProcedures = [] as any;
                for (let item of _data["surgeryProcedures"])
                    this.surgeryProcedures!.push(LookupDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SurgeryProceduresOutput {
        data = typeof data === 'object' ? data : {};
        let result = new SurgeryProceduresOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.surgeryProcedures)) {
            data["surgeryProcedures"] = [];
            for (let item of this.surgeryProcedures)
                data["surgeryProcedures"].push(item.toJSON());
        }
        return data; 
    }

    clone(): SurgeryProceduresOutput {
        const json = this.toJSON();
        let result = new SurgeryProceduresOutput();
        result.init(json);
        return result;
    }
}

export interface ISurgeryProceduresOutput {
    surgeryProcedures: LookupDto[] | undefined;
}

export class SurgeryProceduresOutputAppResponse implements ISurgeryProceduresOutputAppResponse {
    data!: SurgeryProceduresOutput;
    isSuccessful!: boolean;
    statusCode!: string | undefined;
    statusDescription!: string | undefined;

    constructor(data?: ISurgeryProceduresOutputAppResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? SurgeryProceduresOutput.fromJS(_data["data"]) : <any>undefined;
            this.isSuccessful = _data["isSuccessful"];
            this.statusCode = _data["statusCode"];
            this.statusDescription = _data["statusDescription"];
        }
    }

    static fromJS(data: any): SurgeryProceduresOutputAppResponse {
        data = typeof data === 'object' ? data : {};
        let result = new SurgeryProceduresOutputAppResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["isSuccessful"] = this.isSuccessful;
        data["statusCode"] = this.statusCode;
        data["statusDescription"] = this.statusDescription;
        return data; 
    }

    clone(): SurgeryProceduresOutputAppResponse {
        const json = this.toJSON();
        let result = new SurgeryProceduresOutputAppResponse();
        result.init(json);
        return result;
    }
}

export interface ISurgeryProceduresOutputAppResponse {
    data: SurgeryProceduresOutput;
    isSuccessful: boolean;
    statusCode: string | undefined;
    statusDescription: string | undefined;
}

export class EditSurgeryProcedureInput implements IEditSurgeryProcedureInput {
    points!: number;
    number!: number;
    name!: string;

    constructor(data?: IEditSurgeryProcedureInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.points = _data["points"];
            this.number = _data["number"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): EditSurgeryProcedureInput {
        data = typeof data === 'object' ? data : {};
        let result = new EditSurgeryProcedureInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["points"] = this.points;
        data["number"] = this.number;
        data["name"] = this.name;
        return data; 
    }

    clone(): EditSurgeryProcedureInput {
        const json = this.toJSON();
        let result = new EditSurgeryProcedureInput();
        result.init(json);
        return result;
    }
}

export interface IEditSurgeryProcedureInput {
    points: number;
    number: number;
    name: string;
}

export class HospitalContactDto implements IHospitalContactDto {
    id!: number;
    name!: string | undefined;
    departmentName!: string | undefined;
    extensionNumber!: string | undefined;
    note!: string | undefined;
    email!: string | undefined;
    phone!: string | undefined;
    fax!: string | undefined;

    constructor(data?: IHospitalContactDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.departmentName = _data["departmentName"];
            this.extensionNumber = _data["extensionNumber"];
            this.note = _data["note"];
            this.email = _data["email"];
            this.phone = _data["phone"];
            this.fax = _data["fax"];
        }
    }

    static fromJS(data: any): HospitalContactDto {
        data = typeof data === 'object' ? data : {};
        let result = new HospitalContactDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["departmentName"] = this.departmentName;
        data["extensionNumber"] = this.extensionNumber;
        data["note"] = this.note;
        data["email"] = this.email;
        data["phone"] = this.phone;
        data["fax"] = this.fax;
        return data; 
    }

    clone(): HospitalContactDto {
        const json = this.toJSON();
        let result = new HospitalContactDto();
        result.init(json);
        return result;
    }
}

export interface IHospitalContactDto {
    id: number;
    name: string | undefined;
    departmentName: string | undefined;
    extensionNumber: string | undefined;
    note: string | undefined;
    email: string | undefined;
    phone: string | undefined;
    fax: string | undefined;
}

export class HospitalInput implements IHospitalInput {
    name!: string;
    regionalId!: string;
    email!: string | undefined;
    address!: string;
    note!: string | undefined;
    websiteUrl!: string | undefined;
    phone!: string | undefined;
    fax!: string | undefined;
    accountId!: number;
    hospitalContacts!: HospitalContactDto[] | undefined;

    constructor(data?: IHospitalInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.regionalId = _data["regionalId"];
            this.email = _data["email"];
            this.address = _data["address"];
            this.note = _data["note"];
            this.websiteUrl = _data["websiteUrl"];
            this.phone = _data["phone"];
            this.fax = _data["fax"];
            this.accountId = _data["accountId"];
            if (Array.isArray(_data["hospitalContacts"])) {
                this.hospitalContacts = [] as any;
                for (let item of _data["hospitalContacts"])
                    this.hospitalContacts!.push(HospitalContactDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): HospitalInput {
        data = typeof data === 'object' ? data : {};
        let result = new HospitalInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["regionalId"] = this.regionalId;
        data["email"] = this.email;
        data["address"] = this.address;
        data["note"] = this.note;
        data["websiteUrl"] = this.websiteUrl;
        data["phone"] = this.phone;
        data["fax"] = this.fax;
        data["accountId"] = this.accountId;
        if (Array.isArray(this.hospitalContacts)) {
            data["hospitalContacts"] = [];
            for (let item of this.hospitalContacts)
                data["hospitalContacts"].push(item.toJSON());
        }
        return data; 
    }

    clone(): HospitalInput {
        const json = this.toJSON();
        let result = new HospitalInput();
        result.init(json);
        return result;
    }
}

export interface IHospitalInput {
    name: string;
    regionalId: string;
    email: string | undefined;
    address: string;
    note: string | undefined;
    websiteUrl: string | undefined;
    phone: string | undefined;
    fax: string | undefined;
    accountId: number;
    hospitalContacts: HospitalContactDto[] | undefined;
}

export class HospitalDto implements IHospitalDto {
    regionalId!: string | undefined;
    address!: string | undefined;
    note!: string | undefined;
    websiteUrl!: string | undefined;
    email!: string | undefined;
    phone!: string | undefined;
    fax!: string | undefined;
    hospitalContacts!: HospitalContactDto[] | undefined;

    constructor(data?: IHospitalDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.regionalId = _data["regionalId"];
            this.address = _data["address"];
            this.note = _data["note"];
            this.websiteUrl = _data["websiteUrl"];
            this.email = _data["email"];
            this.phone = _data["phone"];
            this.fax = _data["fax"];
            if (Array.isArray(_data["hospitalContacts"])) {
                this.hospitalContacts = [] as any;
                for (let item of _data["hospitalContacts"])
                    this.hospitalContacts!.push(HospitalContactDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): HospitalDto {
        data = typeof data === 'object' ? data : {};
        let result = new HospitalDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["regionalId"] = this.regionalId;
        data["address"] = this.address;
        data["note"] = this.note;
        data["websiteUrl"] = this.websiteUrl;
        data["email"] = this.email;
        data["phone"] = this.phone;
        data["fax"] = this.fax;
        if (Array.isArray(this.hospitalContacts)) {
            data["hospitalContacts"] = [];
            for (let item of this.hospitalContacts)
                data["hospitalContacts"].push(item.toJSON());
        }
        return data; 
    }

    clone(): HospitalDto {
        const json = this.toJSON();
        let result = new HospitalDto();
        result.init(json);
        return result;
    }
}

export interface IHospitalDto {
    regionalId: string | undefined;
    address: string | undefined;
    note: string | undefined;
    websiteUrl: string | undefined;
    email: string | undefined;
    phone: string | undefined;
    fax: string | undefined;
    hospitalContacts: HospitalContactDto[] | undefined;
}

export class HospitalsQueryOutput implements IHospitalsQueryOutput {
    hospitals!: HospitalDto[] | undefined;

    constructor(data?: IHospitalsQueryOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["hospitals"])) {
                this.hospitals = [] as any;
                for (let item of _data["hospitals"])
                    this.hospitals!.push(HospitalDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): HospitalsQueryOutput {
        data = typeof data === 'object' ? data : {};
        let result = new HospitalsQueryOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.hospitals)) {
            data["hospitals"] = [];
            for (let item of this.hospitals)
                data["hospitals"].push(item.toJSON());
        }
        return data; 
    }

    clone(): HospitalsQueryOutput {
        const json = this.toJSON();
        let result = new HospitalsQueryOutput();
        result.init(json);
        return result;
    }
}

export interface IHospitalsQueryOutput {
    hospitals: HospitalDto[] | undefined;
}

export class HospitalsQueryOutputAppResponse implements IHospitalsQueryOutputAppResponse {
    data!: HospitalsQueryOutput;
    isSuccessful!: boolean;
    statusCode!: string | undefined;
    statusDescription!: string | undefined;

    constructor(data?: IHospitalsQueryOutputAppResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? HospitalsQueryOutput.fromJS(_data["data"]) : <any>undefined;
            this.isSuccessful = _data["isSuccessful"];
            this.statusCode = _data["statusCode"];
            this.statusDescription = _data["statusDescription"];
        }
    }

    static fromJS(data: any): HospitalsQueryOutputAppResponse {
        data = typeof data === 'object' ? data : {};
        let result = new HospitalsQueryOutputAppResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["isSuccessful"] = this.isSuccessful;
        data["statusCode"] = this.statusCode;
        data["statusDescription"] = this.statusDescription;
        return data; 
    }

    clone(): HospitalsQueryOutputAppResponse {
        const json = this.toJSON();
        let result = new HospitalsQueryOutputAppResponse();
        result.init(json);
        return result;
    }
}

export interface IHospitalsQueryOutputAppResponse {
    data: HospitalsQueryOutput;
    isSuccessful: boolean;
    statusCode: string | undefined;
    statusDescription: string | undefined;
}

export class HospitalDtoAppResponse implements IHospitalDtoAppResponse {
    data!: HospitalDto;
    isSuccessful!: boolean;
    statusCode!: string | undefined;
    statusDescription!: string | undefined;

    constructor(data?: IHospitalDtoAppResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? HospitalDto.fromJS(_data["data"]) : <any>undefined;
            this.isSuccessful = _data["isSuccessful"];
            this.statusCode = _data["statusCode"];
            this.statusDescription = _data["statusDescription"];
        }
    }

    static fromJS(data: any): HospitalDtoAppResponse {
        data = typeof data === 'object' ? data : {};
        let result = new HospitalDtoAppResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["isSuccessful"] = this.isSuccessful;
        data["statusCode"] = this.statusCode;
        data["statusDescription"] = this.statusDescription;
        return data; 
    }

    clone(): HospitalDtoAppResponse {
        const json = this.toJSON();
        let result = new HospitalDtoAppResponse();
        result.init(json);
        return result;
    }
}

export interface IHospitalDtoAppResponse {
    data: HospitalDto;
    isSuccessful: boolean;
    statusCode: string | undefined;
    statusDescription: string | undefined;
}

export class StringIEnumerableAppResponse implements IStringIEnumerableAppResponse {
    data!: string[] | undefined;
    isSuccessful!: boolean;
    statusCode!: string | undefined;
    statusDescription!: string | undefined;

    constructor(data?: IStringIEnumerableAppResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(item);
            }
            this.isSuccessful = _data["isSuccessful"];
            this.statusCode = _data["statusCode"];
            this.statusDescription = _data["statusDescription"];
        }
    }

    static fromJS(data: any): StringIEnumerableAppResponse {
        data = typeof data === 'object' ? data : {};
        let result = new StringIEnumerableAppResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item);
        }
        data["isSuccessful"] = this.isSuccessful;
        data["statusCode"] = this.statusCode;
        data["statusDescription"] = this.statusDescription;
        return data; 
    }

    clone(): StringIEnumerableAppResponse {
        const json = this.toJSON();
        let result = new StringIEnumerableAppResponse();
        result.init(json);
        return result;
    }
}

export interface IStringIEnumerableAppResponse {
    data: string[] | undefined;
    isSuccessful: boolean;
    statusCode: string | undefined;
    statusDescription: string | undefined;
}

export enum Gender {
    _1 = 1,
    _2 = 2,
}

export enum SocialStatus {
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
}

export enum EducationalLevel {
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
}

export class CreatePatientInput implements ICreatePatientInput {
    idNumber!: string;
    name!: string;
    profileNumber!: string | undefined;
    phoneNumber!: string;
    birthDate!: moment.Moment;
    height!: number | undefined;
    weight!: number | undefined;
    gender!: Gender;
    email!: string | undefined;
    address!: string | undefined;
    hasHealthInsurance!: boolean;
    nationality!: string | undefined;
    socialStatus!: SocialStatus;
    familyMembersCount!: number | undefined;
    familyIncome!: number | undefined;
    educationalLevel!: EducationalLevel;
    job!: string | undefined;
    painDegree!: number | undefined;
    surgeries!: string | undefined;
    permanentTreatments!: string | undefined;
    doctorId!: number;
    insuranceNumber!: string;
    medicalVisitPayloadRatio!: number;
    medicalProceduresPayloadRatio!: number;
    startDate!: moment.Moment;
    expiryDate!: moment.Moment;
    notes!: string | undefined;
    insuranceCompanyId!: number;

    constructor(data?: ICreatePatientInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.idNumber = _data["idNumber"];
            this.name = _data["name"];
            this.profileNumber = _data["profileNumber"];
            this.phoneNumber = _data["phoneNumber"];
            this.birthDate = _data["birthDate"] ? moment(_data["birthDate"].toString()) : <any>undefined;
            this.height = _data["height"];
            this.weight = _data["weight"];
            this.gender = _data["gender"];
            this.email = _data["email"];
            this.address = _data["address"];
            this.hasHealthInsurance = _data["hasHealthInsurance"];
            this.nationality = _data["nationality"];
            this.socialStatus = _data["socialStatus"];
            this.familyMembersCount = _data["familyMembersCount"];
            this.familyIncome = _data["familyIncome"];
            this.educationalLevel = _data["educationalLevel"];
            this.job = _data["job"];
            this.painDegree = _data["painDegree"];
            this.surgeries = _data["surgeries"];
            this.permanentTreatments = _data["permanentTreatments"];
            this.doctorId = _data["doctorId"];
            this.insuranceNumber = _data["insuranceNumber"];
            this.medicalVisitPayloadRatio = _data["medicalVisitPayloadRatio"];
            this.medicalProceduresPayloadRatio = _data["medicalProceduresPayloadRatio"];
            this.startDate = _data["startDate"] ? moment(_data["startDate"].toString()) : <any>undefined;
            this.expiryDate = _data["expiryDate"] ? moment(_data["expiryDate"].toString()) : <any>undefined;
            this.notes = _data["notes"];
            this.insuranceCompanyId = _data["insuranceCompanyId"];
        }
    }

    static fromJS(data: any): CreatePatientInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreatePatientInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["idNumber"] = this.idNumber;
        data["name"] = this.name;
        data["profileNumber"] = this.profileNumber;
        data["phoneNumber"] = this.phoneNumber;
        data["birthDate"] = this.birthDate ? this.birthDate.toISOString() : <any>undefined;
        data["height"] = this.height;
        data["weight"] = this.weight;
        data["gender"] = this.gender;
        data["email"] = this.email;
        data["address"] = this.address;
        data["hasHealthInsurance"] = this.hasHealthInsurance;
        data["nationality"] = this.nationality;
        data["socialStatus"] = this.socialStatus;
        data["familyMembersCount"] = this.familyMembersCount;
        data["familyIncome"] = this.familyIncome;
        data["educationalLevel"] = this.educationalLevel;
        data["job"] = this.job;
        data["painDegree"] = this.painDegree;
        data["surgeries"] = this.surgeries;
        data["permanentTreatments"] = this.permanentTreatments;
        data["doctorId"] = this.doctorId;
        data["insuranceNumber"] = this.insuranceNumber;
        data["medicalVisitPayloadRatio"] = this.medicalVisitPayloadRatio;
        data["medicalProceduresPayloadRatio"] = this.medicalProceduresPayloadRatio;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["expiryDate"] = this.expiryDate ? this.expiryDate.toISOString() : <any>undefined;
        data["notes"] = this.notes;
        data["insuranceCompanyId"] = this.insuranceCompanyId;
        return data; 
    }

    clone(): CreatePatientInput {
        const json = this.toJSON();
        let result = new CreatePatientInput();
        result.init(json);
        return result;
    }
}

export interface ICreatePatientInput {
    idNumber: string;
    name: string;
    profileNumber: string | undefined;
    phoneNumber: string;
    birthDate: moment.Moment;
    height: number | undefined;
    weight: number | undefined;
    gender: Gender;
    email: string | undefined;
    address: string | undefined;
    hasHealthInsurance: boolean;
    nationality: string | undefined;
    socialStatus: SocialStatus;
    familyMembersCount: number | undefined;
    familyIncome: number | undefined;
    educationalLevel: EducationalLevel;
    job: string | undefined;
    painDegree: number | undefined;
    surgeries: string | undefined;
    permanentTreatments: string | undefined;
    doctorId: number;
    insuranceNumber: string;
    medicalVisitPayloadRatio: number;
    medicalProceduresPayloadRatio: number;
    startDate: moment.Moment;
    expiryDate: moment.Moment;
    notes: string | undefined;
    insuranceCompanyId: number;
}

export class PatientQueryDto implements IPatientQueryDto {
    id!: number;
    idNumber!: string | undefined;
    name!: string | undefined;
    profileNumber!: string | undefined;
    phoneNumber!: string | undefined;
    email!: string | undefined;
    doctorName!: string | undefined;
    hasHealthInsurance!: boolean;
    insuranceCompany!: string | undefined;
    lastVisitDate!: moment.Moment;

    constructor(data?: IPatientQueryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.idNumber = _data["idNumber"];
            this.name = _data["name"];
            this.profileNumber = _data["profileNumber"];
            this.phoneNumber = _data["phoneNumber"];
            this.email = _data["email"];
            this.doctorName = _data["doctorName"];
            this.hasHealthInsurance = _data["hasHealthInsurance"];
            this.insuranceCompany = _data["insuranceCompany"];
            this.lastVisitDate = _data["lastVisitDate"] ? moment(_data["lastVisitDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): PatientQueryDto {
        data = typeof data === 'object' ? data : {};
        let result = new PatientQueryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["idNumber"] = this.idNumber;
        data["name"] = this.name;
        data["profileNumber"] = this.profileNumber;
        data["phoneNumber"] = this.phoneNumber;
        data["email"] = this.email;
        data["doctorName"] = this.doctorName;
        data["hasHealthInsurance"] = this.hasHealthInsurance;
        data["insuranceCompany"] = this.insuranceCompany;
        data["lastVisitDate"] = this.lastVisitDate ? this.lastVisitDate.toISOString() : <any>undefined;
        return data; 
    }

    clone(): PatientQueryDto {
        const json = this.toJSON();
        let result = new PatientQueryDto();
        result.init(json);
        return result;
    }
}

export interface IPatientQueryDto {
    id: number;
    idNumber: string | undefined;
    name: string | undefined;
    profileNumber: string | undefined;
    phoneNumber: string | undefined;
    email: string | undefined;
    doctorName: string | undefined;
    hasHealthInsurance: boolean;
    insuranceCompany: string | undefined;
    lastVisitDate: moment.Moment;
}

export class PatientsQueryOutput implements IPatientsQueryOutput {
    patients!: PatientQueryDto[] | undefined;

    constructor(data?: IPatientsQueryOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["patients"])) {
                this.patients = [] as any;
                for (let item of _data["patients"])
                    this.patients!.push(PatientQueryDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PatientsQueryOutput {
        data = typeof data === 'object' ? data : {};
        let result = new PatientsQueryOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.patients)) {
            data["patients"] = [];
            for (let item of this.patients)
                data["patients"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PatientsQueryOutput {
        const json = this.toJSON();
        let result = new PatientsQueryOutput();
        result.init(json);
        return result;
    }
}

export interface IPatientsQueryOutput {
    patients: PatientQueryDto[] | undefined;
}

export class PatientsQueryOutputAppResponse implements IPatientsQueryOutputAppResponse {
    data!: PatientsQueryOutput;
    isSuccessful!: boolean;
    statusCode!: string | undefined;
    statusDescription!: string | undefined;

    constructor(data?: IPatientsQueryOutputAppResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? PatientsQueryOutput.fromJS(_data["data"]) : <any>undefined;
            this.isSuccessful = _data["isSuccessful"];
            this.statusCode = _data["statusCode"];
            this.statusDescription = _data["statusDescription"];
        }
    }

    static fromJS(data: any): PatientsQueryOutputAppResponse {
        data = typeof data === 'object' ? data : {};
        let result = new PatientsQueryOutputAppResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["isSuccessful"] = this.isSuccessful;
        data["statusCode"] = this.statusCode;
        data["statusDescription"] = this.statusDescription;
        return data; 
    }

    clone(): PatientsQueryOutputAppResponse {
        const json = this.toJSON();
        let result = new PatientsQueryOutputAppResponse();
        result.init(json);
        return result;
    }
}

export interface IPatientsQueryOutputAppResponse {
    data: PatientsQueryOutput;
    isSuccessful: boolean;
    statusCode: string | undefined;
    statusDescription: string | undefined;
}

export class SystemAccountSubTypeInput implements ISystemAccountSubTypeInput {
    accountTypeId!: number;
    notes!: string | undefined;
    name!: string;

    constructor(data?: ISystemAccountSubTypeInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accountTypeId = _data["accountTypeId"];
            this.notes = _data["notes"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): SystemAccountSubTypeInput {
        data = typeof data === 'object' ? data : {};
        let result = new SystemAccountSubTypeInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accountTypeId"] = this.accountTypeId;
        data["notes"] = this.notes;
        data["name"] = this.name;
        return data; 
    }

    clone(): SystemAccountSubTypeInput {
        const json = this.toJSON();
        let result = new SystemAccountSubTypeInput();
        result.init(json);
        return result;
    }
}

export interface ISystemAccountSubTypeInput {
    accountTypeId: number;
    notes: string | undefined;
    name: string;
}

export class SystemAccountTypeDto implements ISystemAccountTypeDto {
    id!: number;
    status!: LookupStatus;
    name!: string | undefined;

    constructor(data?: ISystemAccountTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.status = _data["status"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): SystemAccountTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new SystemAccountTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["status"] = this.status;
        data["name"] = this.name;
        return data; 
    }

    clone(): SystemAccountTypeDto {
        const json = this.toJSON();
        let result = new SystemAccountTypeDto();
        result.init(json);
        return result;
    }
}

export interface ISystemAccountTypeDto {
    id: number;
    status: LookupStatus;
    name: string | undefined;
}

export class SystemAccountSubTypeDto implements ISystemAccountSubTypeDto {
    accountType!: SystemAccountTypeDto;
    notes!: string | undefined;
    id!: number;
    status!: LookupStatus;
    name!: string | undefined;

    constructor(data?: ISystemAccountSubTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accountType = _data["accountType"] ? SystemAccountTypeDto.fromJS(_data["accountType"]) : <any>undefined;
            this.notes = _data["notes"];
            this.id = _data["id"];
            this.status = _data["status"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): SystemAccountSubTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new SystemAccountSubTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accountType"] = this.accountType ? this.accountType.toJSON() : <any>undefined;
        data["notes"] = this.notes;
        data["id"] = this.id;
        data["status"] = this.status;
        data["name"] = this.name;
        return data; 
    }

    clone(): SystemAccountSubTypeDto {
        const json = this.toJSON();
        let result = new SystemAccountSubTypeDto();
        result.init(json);
        return result;
    }
}

export interface ISystemAccountSubTypeDto {
    accountType: SystemAccountTypeDto;
    notes: string | undefined;
    id: number;
    status: LookupStatus;
    name: string | undefined;
}

export class SystemAccountSubTypesOutput implements ISystemAccountSubTypesOutput {
    accountSubTypes!: SystemAccountSubTypeDto[] | undefined;

    constructor(data?: ISystemAccountSubTypesOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["accountSubTypes"])) {
                this.accountSubTypes = [] as any;
                for (let item of _data["accountSubTypes"])
                    this.accountSubTypes!.push(SystemAccountSubTypeDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SystemAccountSubTypesOutput {
        data = typeof data === 'object' ? data : {};
        let result = new SystemAccountSubTypesOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.accountSubTypes)) {
            data["accountSubTypes"] = [];
            for (let item of this.accountSubTypes)
                data["accountSubTypes"].push(item.toJSON());
        }
        return data; 
    }

    clone(): SystemAccountSubTypesOutput {
        const json = this.toJSON();
        let result = new SystemAccountSubTypesOutput();
        result.init(json);
        return result;
    }
}

export interface ISystemAccountSubTypesOutput {
    accountSubTypes: SystemAccountSubTypeDto[] | undefined;
}

export class SystemAccountSubTypesOutputAppResponse implements ISystemAccountSubTypesOutputAppResponse {
    data!: SystemAccountSubTypesOutput;
    isSuccessful!: boolean;
    statusCode!: string | undefined;
    statusDescription!: string | undefined;

    constructor(data?: ISystemAccountSubTypesOutputAppResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? SystemAccountSubTypesOutput.fromJS(_data["data"]) : <any>undefined;
            this.isSuccessful = _data["isSuccessful"];
            this.statusCode = _data["statusCode"];
            this.statusDescription = _data["statusDescription"];
        }
    }

    static fromJS(data: any): SystemAccountSubTypesOutputAppResponse {
        data = typeof data === 'object' ? data : {};
        let result = new SystemAccountSubTypesOutputAppResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["isSuccessful"] = this.isSuccessful;
        data["statusCode"] = this.statusCode;
        data["statusDescription"] = this.statusDescription;
        return data; 
    }

    clone(): SystemAccountSubTypesOutputAppResponse {
        const json = this.toJSON();
        let result = new SystemAccountSubTypesOutputAppResponse();
        result.init(json);
        return result;
    }
}

export interface ISystemAccountSubTypesOutputAppResponse {
    data: SystemAccountSubTypesOutput;
    isSuccessful: boolean;
    statusCode: string | undefined;
    statusDescription: string | undefined;
}

export class SystemAccountSubTypeDtoAppResponse implements ISystemAccountSubTypeDtoAppResponse {
    data!: SystemAccountSubTypeDto;
    isSuccessful!: boolean;
    statusCode!: string | undefined;
    statusDescription!: string | undefined;

    constructor(data?: ISystemAccountSubTypeDtoAppResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? SystemAccountSubTypeDto.fromJS(_data["data"]) : <any>undefined;
            this.isSuccessful = _data["isSuccessful"];
            this.statusCode = _data["statusCode"];
            this.statusDescription = _data["statusDescription"];
        }
    }

    static fromJS(data: any): SystemAccountSubTypeDtoAppResponse {
        data = typeof data === 'object' ? data : {};
        let result = new SystemAccountSubTypeDtoAppResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["isSuccessful"] = this.isSuccessful;
        data["statusCode"] = this.statusCode;
        data["statusDescription"] = this.statusDescription;
        return data; 
    }

    clone(): SystemAccountSubTypeDtoAppResponse {
        const json = this.toJSON();
        let result = new SystemAccountSubTypeDtoAppResponse();
        result.init(json);
        return result;
    }
}

export interface ISystemAccountSubTypeDtoAppResponse {
    data: SystemAccountSubTypeDto;
    isSuccessful: boolean;
    statusCode: string | undefined;
    statusDescription: string | undefined;
}

export class CreateSystemAccountTypeInput implements ICreateSystemAccountTypeInput {
    notes!: string | undefined;
    name!: string;

    constructor(data?: ICreateSystemAccountTypeInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.notes = _data["notes"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): CreateSystemAccountTypeInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateSystemAccountTypeInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["notes"] = this.notes;
        data["name"] = this.name;
        return data; 
    }

    clone(): CreateSystemAccountTypeInput {
        const json = this.toJSON();
        let result = new CreateSystemAccountTypeInput();
        result.init(json);
        return result;
    }
}

export interface ICreateSystemAccountTypeInput {
    notes: string | undefined;
    name: string;
}

export class SystemAccountTypesOutput implements ISystemAccountTypesOutput {
    accountTypes!: LookupDto[] | undefined;

    constructor(data?: ISystemAccountTypesOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["accountTypes"])) {
                this.accountTypes = [] as any;
                for (let item of _data["accountTypes"])
                    this.accountTypes!.push(LookupDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SystemAccountTypesOutput {
        data = typeof data === 'object' ? data : {};
        let result = new SystemAccountTypesOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.accountTypes)) {
            data["accountTypes"] = [];
            for (let item of this.accountTypes)
                data["accountTypes"].push(item.toJSON());
        }
        return data; 
    }

    clone(): SystemAccountTypesOutput {
        const json = this.toJSON();
        let result = new SystemAccountTypesOutput();
        result.init(json);
        return result;
    }
}

export interface ISystemAccountTypesOutput {
    accountTypes: LookupDto[] | undefined;
}

export class SystemAccountTypesOutputAppResponse implements ISystemAccountTypesOutputAppResponse {
    data!: SystemAccountTypesOutput;
    isSuccessful!: boolean;
    statusCode!: string | undefined;
    statusDescription!: string | undefined;

    constructor(data?: ISystemAccountTypesOutputAppResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? SystemAccountTypesOutput.fromJS(_data["data"]) : <any>undefined;
            this.isSuccessful = _data["isSuccessful"];
            this.statusCode = _data["statusCode"];
            this.statusDescription = _data["statusDescription"];
        }
    }

    static fromJS(data: any): SystemAccountTypesOutputAppResponse {
        data = typeof data === 'object' ? data : {};
        let result = new SystemAccountTypesOutputAppResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["isSuccessful"] = this.isSuccessful;
        data["statusCode"] = this.statusCode;
        data["statusDescription"] = this.statusDescription;
        return data; 
    }

    clone(): SystemAccountTypesOutputAppResponse {
        const json = this.toJSON();
        let result = new SystemAccountTypesOutputAppResponse();
        result.init(json);
        return result;
    }
}

export interface ISystemAccountTypesOutputAppResponse {
    data: SystemAccountTypesOutput;
    isSuccessful: boolean;
    statusCode: string | undefined;
    statusDescription: string | undefined;
}

export class EditSystemAccountTypeInput implements IEditSystemAccountTypeInput {
    notes!: string | undefined;
    name!: string;

    constructor(data?: IEditSystemAccountTypeInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.notes = _data["notes"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): EditSystemAccountTypeInput {
        data = typeof data === 'object' ? data : {};
        let result = new EditSystemAccountTypeInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["notes"] = this.notes;
        data["name"] = this.name;
        return data; 
    }

    clone(): EditSystemAccountTypeInput {
        const json = this.toJSON();
        let result = new EditSystemAccountTypeInput();
        result.init(json);
        return result;
    }
}

export interface IEditSystemAccountTypeInput {
    notes: string | undefined;
    name: string;
}

export class SystemAccountTypeDtoAppResponse implements ISystemAccountTypeDtoAppResponse {
    data!: SystemAccountTypeDto;
    isSuccessful!: boolean;
    statusCode!: string | undefined;
    statusDescription!: string | undefined;

    constructor(data?: ISystemAccountTypeDtoAppResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? SystemAccountTypeDto.fromJS(_data["data"]) : <any>undefined;
            this.isSuccessful = _data["isSuccessful"];
            this.statusCode = _data["statusCode"];
            this.statusDescription = _data["statusDescription"];
        }
    }

    static fromJS(data: any): SystemAccountTypeDtoAppResponse {
        data = typeof data === 'object' ? data : {};
        let result = new SystemAccountTypeDtoAppResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["isSuccessful"] = this.isSuccessful;
        data["statusCode"] = this.statusCode;
        data["statusDescription"] = this.statusDescription;
        return data; 
    }

    clone(): SystemAccountTypeDtoAppResponse {
        const json = this.toJSON();
        let result = new SystemAccountTypeDtoAppResponse();
        result.init(json);
        return result;
    }
}

export interface ISystemAccountTypeDtoAppResponse {
    data: SystemAccountTypeDto;
    isSuccessful: boolean;
    statusCode: string | undefined;
    statusDescription: string | undefined;
}

export class CreateSystemAllergicInput implements ICreateSystemAllergicInput {
    name!: string;

    constructor(data?: ICreateSystemAllergicInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): CreateSystemAllergicInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateSystemAllergicInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data; 
    }

    clone(): CreateSystemAllergicInput {
        const json = this.toJSON();
        let result = new CreateSystemAllergicInput();
        result.init(json);
        return result;
    }
}

export interface ICreateSystemAllergicInput {
    name: string;
}

export class SystemAllergiesOutput implements ISystemAllergiesOutput {
    allergies!: LookupDto[] | undefined;

    constructor(data?: ISystemAllergiesOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["allergies"])) {
                this.allergies = [] as any;
                for (let item of _data["allergies"])
                    this.allergies!.push(LookupDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SystemAllergiesOutput {
        data = typeof data === 'object' ? data : {};
        let result = new SystemAllergiesOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.allergies)) {
            data["allergies"] = [];
            for (let item of this.allergies)
                data["allergies"].push(item.toJSON());
        }
        return data; 
    }

    clone(): SystemAllergiesOutput {
        const json = this.toJSON();
        let result = new SystemAllergiesOutput();
        result.init(json);
        return result;
    }
}

export interface ISystemAllergiesOutput {
    allergies: LookupDto[] | undefined;
}

export class SystemAllergiesOutputAppResponse implements ISystemAllergiesOutputAppResponse {
    data!: SystemAllergiesOutput;
    isSuccessful!: boolean;
    statusCode!: string | undefined;
    statusDescription!: string | undefined;

    constructor(data?: ISystemAllergiesOutputAppResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? SystemAllergiesOutput.fromJS(_data["data"]) : <any>undefined;
            this.isSuccessful = _data["isSuccessful"];
            this.statusCode = _data["statusCode"];
            this.statusDescription = _data["statusDescription"];
        }
    }

    static fromJS(data: any): SystemAllergiesOutputAppResponse {
        data = typeof data === 'object' ? data : {};
        let result = new SystemAllergiesOutputAppResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["isSuccessful"] = this.isSuccessful;
        data["statusCode"] = this.statusCode;
        data["statusDescription"] = this.statusDescription;
        return data; 
    }

    clone(): SystemAllergiesOutputAppResponse {
        const json = this.toJSON();
        let result = new SystemAllergiesOutputAppResponse();
        result.init(json);
        return result;
    }
}

export interface ISystemAllergiesOutputAppResponse {
    data: SystemAllergiesOutput;
    isSuccessful: boolean;
    statusCode: string | undefined;
    statusDescription: string | undefined;
}

export class EditSystemAllergicInput implements IEditSystemAllergicInput {
    name!: string;

    constructor(data?: IEditSystemAllergicInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): EditSystemAllergicInput {
        data = typeof data === 'object' ? data : {};
        let result = new EditSystemAllergicInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data; 
    }

    clone(): EditSystemAllergicInput {
        const json = this.toJSON();
        let result = new EditSystemAllergicInput();
        result.init(json);
        return result;
    }
}

export interface IEditSystemAllergicInput {
    name: string;
}

export class SystemAllergicDto implements ISystemAllergicDto {
    id!: number;
    status!: LookupStatus;
    name!: string | undefined;

    constructor(data?: ISystemAllergicDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.status = _data["status"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): SystemAllergicDto {
        data = typeof data === 'object' ? data : {};
        let result = new SystemAllergicDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["status"] = this.status;
        data["name"] = this.name;
        return data; 
    }

    clone(): SystemAllergicDto {
        const json = this.toJSON();
        let result = new SystemAllergicDto();
        result.init(json);
        return result;
    }
}

export interface ISystemAllergicDto {
    id: number;
    status: LookupStatus;
    name: string | undefined;
}

export class SystemAllergicDtoAppResponse implements ISystemAllergicDtoAppResponse {
    data!: SystemAllergicDto;
    isSuccessful!: boolean;
    statusCode!: string | undefined;
    statusDescription!: string | undefined;

    constructor(data?: ISystemAllergicDtoAppResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? SystemAllergicDto.fromJS(_data["data"]) : <any>undefined;
            this.isSuccessful = _data["isSuccessful"];
            this.statusCode = _data["statusCode"];
            this.statusDescription = _data["statusDescription"];
        }
    }

    static fromJS(data: any): SystemAllergicDtoAppResponse {
        data = typeof data === 'object' ? data : {};
        let result = new SystemAllergicDtoAppResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["isSuccessful"] = this.isSuccessful;
        data["statusCode"] = this.statusCode;
        data["statusDescription"] = this.statusDescription;
        return data; 
    }

    clone(): SystemAllergicDtoAppResponse {
        const json = this.toJSON();
        let result = new SystemAllergicDtoAppResponse();
        result.init(json);
        return result;
    }
}

export interface ISystemAllergicDtoAppResponse {
    data: SystemAllergicDto;
    isSuccessful: boolean;
    statusCode: string | undefined;
    statusDescription: string | undefined;
}

export class CreateSystemBankInput implements ICreateSystemBankInput {
    name!: string;

    constructor(data?: ICreateSystemBankInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): CreateSystemBankInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateSystemBankInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data; 
    }

    clone(): CreateSystemBankInput {
        const json = this.toJSON();
        let result = new CreateSystemBankInput();
        result.init(json);
        return result;
    }
}

export interface ICreateSystemBankInput {
    name: string;
}

export class SystemBanksOutput implements ISystemBanksOutput {
    banks!: LookupDto[] | undefined;

    constructor(data?: ISystemBanksOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["banks"])) {
                this.banks = [] as any;
                for (let item of _data["banks"])
                    this.banks!.push(LookupDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SystemBanksOutput {
        data = typeof data === 'object' ? data : {};
        let result = new SystemBanksOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.banks)) {
            data["banks"] = [];
            for (let item of this.banks)
                data["banks"].push(item.toJSON());
        }
        return data; 
    }

    clone(): SystemBanksOutput {
        const json = this.toJSON();
        let result = new SystemBanksOutput();
        result.init(json);
        return result;
    }
}

export interface ISystemBanksOutput {
    banks: LookupDto[] | undefined;
}

export class SystemBanksOutputAppResponse implements ISystemBanksOutputAppResponse {
    data!: SystemBanksOutput;
    isSuccessful!: boolean;
    statusCode!: string | undefined;
    statusDescription!: string | undefined;

    constructor(data?: ISystemBanksOutputAppResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? SystemBanksOutput.fromJS(_data["data"]) : <any>undefined;
            this.isSuccessful = _data["isSuccessful"];
            this.statusCode = _data["statusCode"];
            this.statusDescription = _data["statusDescription"];
        }
    }

    static fromJS(data: any): SystemBanksOutputAppResponse {
        data = typeof data === 'object' ? data : {};
        let result = new SystemBanksOutputAppResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["isSuccessful"] = this.isSuccessful;
        data["statusCode"] = this.statusCode;
        data["statusDescription"] = this.statusDescription;
        return data; 
    }

    clone(): SystemBanksOutputAppResponse {
        const json = this.toJSON();
        let result = new SystemBanksOutputAppResponse();
        result.init(json);
        return result;
    }
}

export interface ISystemBanksOutputAppResponse {
    data: SystemBanksOutput;
    isSuccessful: boolean;
    statusCode: string | undefined;
    statusDescription: string | undefined;
}

export class EditSystemBankInput implements IEditSystemBankInput {
    name!: string;

    constructor(data?: IEditSystemBankInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): EditSystemBankInput {
        data = typeof data === 'object' ? data : {};
        let result = new EditSystemBankInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data; 
    }

    clone(): EditSystemBankInput {
        const json = this.toJSON();
        let result = new EditSystemBankInput();
        result.init(json);
        return result;
    }
}

export interface IEditSystemBankInput {
    name: string;
}

export class SystemBankDto implements ISystemBankDto {
    id!: number;
    status!: LookupStatus;
    name!: string | undefined;

    constructor(data?: ISystemBankDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.status = _data["status"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): SystemBankDto {
        data = typeof data === 'object' ? data : {};
        let result = new SystemBankDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["status"] = this.status;
        data["name"] = this.name;
        return data; 
    }

    clone(): SystemBankDto {
        const json = this.toJSON();
        let result = new SystemBankDto();
        result.init(json);
        return result;
    }
}

export interface ISystemBankDto {
    id: number;
    status: LookupStatus;
    name: string | undefined;
}

export class SystemBankDtoAppResponse implements ISystemBankDtoAppResponse {
    data!: SystemBankDto;
    isSuccessful!: boolean;
    statusCode!: string | undefined;
    statusDescription!: string | undefined;

    constructor(data?: ISystemBankDtoAppResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? SystemBankDto.fromJS(_data["data"]) : <any>undefined;
            this.isSuccessful = _data["isSuccessful"];
            this.statusCode = _data["statusCode"];
            this.statusDescription = _data["statusDescription"];
        }
    }

    static fromJS(data: any): SystemBankDtoAppResponse {
        data = typeof data === 'object' ? data : {};
        let result = new SystemBankDtoAppResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["isSuccessful"] = this.isSuccessful;
        data["statusCode"] = this.statusCode;
        data["statusDescription"] = this.statusDescription;
        return data; 
    }

    clone(): SystemBankDtoAppResponse {
        const json = this.toJSON();
        let result = new SystemBankDtoAppResponse();
        result.init(json);
        return result;
    }
}

export interface ISystemBankDtoAppResponse {
    data: SystemBankDto;
    isSuccessful: boolean;
    statusCode: string | undefined;
    statusDescription: string | undefined;
}

export class CreateSystemComplaintInput implements ICreateSystemComplaintInput {
    name!: string;

    constructor(data?: ICreateSystemComplaintInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): CreateSystemComplaintInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateSystemComplaintInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data; 
    }

    clone(): CreateSystemComplaintInput {
        const json = this.toJSON();
        let result = new CreateSystemComplaintInput();
        result.init(json);
        return result;
    }
}

export interface ICreateSystemComplaintInput {
    name: string;
}

export class SystemComplaintDto implements ISystemComplaintDto {
    id!: number;
    status!: LookupStatus;
    name!: string | undefined;

    constructor(data?: ISystemComplaintDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.status = _data["status"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): SystemComplaintDto {
        data = typeof data === 'object' ? data : {};
        let result = new SystemComplaintDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["status"] = this.status;
        data["name"] = this.name;
        return data; 
    }

    clone(): SystemComplaintDto {
        const json = this.toJSON();
        let result = new SystemComplaintDto();
        result.init(json);
        return result;
    }
}

export interface ISystemComplaintDto {
    id: number;
    status: LookupStatus;
    name: string | undefined;
}

export class SystemComplaintsOutput implements ISystemComplaintsOutput {
    complaints!: SystemComplaintDto[] | undefined;

    constructor(data?: ISystemComplaintsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["complaints"])) {
                this.complaints = [] as any;
                for (let item of _data["complaints"])
                    this.complaints!.push(SystemComplaintDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SystemComplaintsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new SystemComplaintsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.complaints)) {
            data["complaints"] = [];
            for (let item of this.complaints)
                data["complaints"].push(item.toJSON());
        }
        return data; 
    }

    clone(): SystemComplaintsOutput {
        const json = this.toJSON();
        let result = new SystemComplaintsOutput();
        result.init(json);
        return result;
    }
}

export interface ISystemComplaintsOutput {
    complaints: SystemComplaintDto[] | undefined;
}

export class SystemComplaintsOutputAppResponse implements ISystemComplaintsOutputAppResponse {
    data!: SystemComplaintsOutput;
    isSuccessful!: boolean;
    statusCode!: string | undefined;
    statusDescription!: string | undefined;

    constructor(data?: ISystemComplaintsOutputAppResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? SystemComplaintsOutput.fromJS(_data["data"]) : <any>undefined;
            this.isSuccessful = _data["isSuccessful"];
            this.statusCode = _data["statusCode"];
            this.statusDescription = _data["statusDescription"];
        }
    }

    static fromJS(data: any): SystemComplaintsOutputAppResponse {
        data = typeof data === 'object' ? data : {};
        let result = new SystemComplaintsOutputAppResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["isSuccessful"] = this.isSuccessful;
        data["statusCode"] = this.statusCode;
        data["statusDescription"] = this.statusDescription;
        return data; 
    }

    clone(): SystemComplaintsOutputAppResponse {
        const json = this.toJSON();
        let result = new SystemComplaintsOutputAppResponse();
        result.init(json);
        return result;
    }
}

export interface ISystemComplaintsOutputAppResponse {
    data: SystemComplaintsOutput;
    isSuccessful: boolean;
    statusCode: string | undefined;
    statusDescription: string | undefined;
}

export class EditSystemComplaintInput implements IEditSystemComplaintInput {
    name!: string;

    constructor(data?: IEditSystemComplaintInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): EditSystemComplaintInput {
        data = typeof data === 'object' ? data : {};
        let result = new EditSystemComplaintInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data; 
    }

    clone(): EditSystemComplaintInput {
        const json = this.toJSON();
        let result = new EditSystemComplaintInput();
        result.init(json);
        return result;
    }
}

export interface IEditSystemComplaintInput {
    name: string;
}

export class SystemComplaintDtoAppResponse implements ISystemComplaintDtoAppResponse {
    data!: SystemComplaintDto;
    isSuccessful!: boolean;
    statusCode!: string | undefined;
    statusDescription!: string | undefined;

    constructor(data?: ISystemComplaintDtoAppResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? SystemComplaintDto.fromJS(_data["data"]) : <any>undefined;
            this.isSuccessful = _data["isSuccessful"];
            this.statusCode = _data["statusCode"];
            this.statusDescription = _data["statusDescription"];
        }
    }

    static fromJS(data: any): SystemComplaintDtoAppResponse {
        data = typeof data === 'object' ? data : {};
        let result = new SystemComplaintDtoAppResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["isSuccessful"] = this.isSuccessful;
        data["statusCode"] = this.statusCode;
        data["statusDescription"] = this.statusDescription;
        return data; 
    }

    clone(): SystemComplaintDtoAppResponse {
        const json = this.toJSON();
        let result = new SystemComplaintDtoAppResponse();
        result.init(json);
        return result;
    }
}

export interface ISystemComplaintDtoAppResponse {
    data: SystemComplaintDto;
    isSuccessful: boolean;
    statusCode: string | undefined;
    statusDescription: string | undefined;
}

export class CreateSystemDiagnosisInput implements ICreateSystemDiagnosisInput {
    name!: string;

    constructor(data?: ICreateSystemDiagnosisInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): CreateSystemDiagnosisInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateSystemDiagnosisInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data; 
    }

    clone(): CreateSystemDiagnosisInput {
        const json = this.toJSON();
        let result = new CreateSystemDiagnosisInput();
        result.init(json);
        return result;
    }
}

export interface ICreateSystemDiagnosisInput {
    name: string;
}

export class SystemDiagnosisDto implements ISystemDiagnosisDto {
    id!: number;
    status!: LookupStatus;
    name!: string | undefined;

    constructor(data?: ISystemDiagnosisDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.status = _data["status"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): SystemDiagnosisDto {
        data = typeof data === 'object' ? data : {};
        let result = new SystemDiagnosisDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["status"] = this.status;
        data["name"] = this.name;
        return data; 
    }

    clone(): SystemDiagnosisDto {
        const json = this.toJSON();
        let result = new SystemDiagnosisDto();
        result.init(json);
        return result;
    }
}

export interface ISystemDiagnosisDto {
    id: number;
    status: LookupStatus;
    name: string | undefined;
}

export class SystemDiagnosisOutput implements ISystemDiagnosisOutput {
    diagnoses!: SystemDiagnosisDto[] | undefined;

    constructor(data?: ISystemDiagnosisOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["diagnoses"])) {
                this.diagnoses = [] as any;
                for (let item of _data["diagnoses"])
                    this.diagnoses!.push(SystemDiagnosisDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SystemDiagnosisOutput {
        data = typeof data === 'object' ? data : {};
        let result = new SystemDiagnosisOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.diagnoses)) {
            data["diagnoses"] = [];
            for (let item of this.diagnoses)
                data["diagnoses"].push(item.toJSON());
        }
        return data; 
    }

    clone(): SystemDiagnosisOutput {
        const json = this.toJSON();
        let result = new SystemDiagnosisOutput();
        result.init(json);
        return result;
    }
}

export interface ISystemDiagnosisOutput {
    diagnoses: SystemDiagnosisDto[] | undefined;
}

export class SystemDiagnosisOutputAppResponse implements ISystemDiagnosisOutputAppResponse {
    data!: SystemDiagnosisOutput;
    isSuccessful!: boolean;
    statusCode!: string | undefined;
    statusDescription!: string | undefined;

    constructor(data?: ISystemDiagnosisOutputAppResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? SystemDiagnosisOutput.fromJS(_data["data"]) : <any>undefined;
            this.isSuccessful = _data["isSuccessful"];
            this.statusCode = _data["statusCode"];
            this.statusDescription = _data["statusDescription"];
        }
    }

    static fromJS(data: any): SystemDiagnosisOutputAppResponse {
        data = typeof data === 'object' ? data : {};
        let result = new SystemDiagnosisOutputAppResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["isSuccessful"] = this.isSuccessful;
        data["statusCode"] = this.statusCode;
        data["statusDescription"] = this.statusDescription;
        return data; 
    }

    clone(): SystemDiagnosisOutputAppResponse {
        const json = this.toJSON();
        let result = new SystemDiagnosisOutputAppResponse();
        result.init(json);
        return result;
    }
}

export interface ISystemDiagnosisOutputAppResponse {
    data: SystemDiagnosisOutput;
    isSuccessful: boolean;
    statusCode: string | undefined;
    statusDescription: string | undefined;
}

export class EditSystemDiagnosisInput implements IEditSystemDiagnosisInput {
    name!: string;

    constructor(data?: IEditSystemDiagnosisInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): EditSystemDiagnosisInput {
        data = typeof data === 'object' ? data : {};
        let result = new EditSystemDiagnosisInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data; 
    }

    clone(): EditSystemDiagnosisInput {
        const json = this.toJSON();
        let result = new EditSystemDiagnosisInput();
        result.init(json);
        return result;
    }
}

export interface IEditSystemDiagnosisInput {
    name: string;
}

export class SystemDiagnosisDtoAppResponse implements ISystemDiagnosisDtoAppResponse {
    data!: SystemDiagnosisDto;
    isSuccessful!: boolean;
    statusCode!: string | undefined;
    statusDescription!: string | undefined;

    constructor(data?: ISystemDiagnosisDtoAppResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? SystemDiagnosisDto.fromJS(_data["data"]) : <any>undefined;
            this.isSuccessful = _data["isSuccessful"];
            this.statusCode = _data["statusCode"];
            this.statusDescription = _data["statusDescription"];
        }
    }

    static fromJS(data: any): SystemDiagnosisDtoAppResponse {
        data = typeof data === 'object' ? data : {};
        let result = new SystemDiagnosisDtoAppResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["isSuccessful"] = this.isSuccessful;
        data["statusCode"] = this.statusCode;
        data["statusDescription"] = this.statusDescription;
        return data; 
    }

    clone(): SystemDiagnosisDtoAppResponse {
        const json = this.toJSON();
        let result = new SystemDiagnosisDtoAppResponse();
        result.init(json);
        return result;
    }
}

export interface ISystemDiagnosisDtoAppResponse {
    data: SystemDiagnosisDto;
    isSuccessful: boolean;
    statusCode: string | undefined;
    statusDescription: string | undefined;
}

export class CreateSystemDiseaseInput implements ICreateSystemDiseaseInput {
    name!: string;

    constructor(data?: ICreateSystemDiseaseInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): CreateSystemDiseaseInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateSystemDiseaseInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data; 
    }

    clone(): CreateSystemDiseaseInput {
        const json = this.toJSON();
        let result = new CreateSystemDiseaseInput();
        result.init(json);
        return result;
    }
}

export interface ICreateSystemDiseaseInput {
    name: string;
}

export class SystemDiseaseDto implements ISystemDiseaseDto {
    id!: number;
    status!: LookupStatus;
    name!: string | undefined;

    constructor(data?: ISystemDiseaseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.status = _data["status"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): SystemDiseaseDto {
        data = typeof data === 'object' ? data : {};
        let result = new SystemDiseaseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["status"] = this.status;
        data["name"] = this.name;
        return data; 
    }

    clone(): SystemDiseaseDto {
        const json = this.toJSON();
        let result = new SystemDiseaseDto();
        result.init(json);
        return result;
    }
}

export interface ISystemDiseaseDto {
    id: number;
    status: LookupStatus;
    name: string | undefined;
}

export class SystemDiseasesOutput implements ISystemDiseasesOutput {
    diseases!: SystemDiseaseDto[] | undefined;

    constructor(data?: ISystemDiseasesOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["diseases"])) {
                this.diseases = [] as any;
                for (let item of _data["diseases"])
                    this.diseases!.push(SystemDiseaseDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SystemDiseasesOutput {
        data = typeof data === 'object' ? data : {};
        let result = new SystemDiseasesOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.diseases)) {
            data["diseases"] = [];
            for (let item of this.diseases)
                data["diseases"].push(item.toJSON());
        }
        return data; 
    }

    clone(): SystemDiseasesOutput {
        const json = this.toJSON();
        let result = new SystemDiseasesOutput();
        result.init(json);
        return result;
    }
}

export interface ISystemDiseasesOutput {
    diseases: SystemDiseaseDto[] | undefined;
}

export class SystemDiseasesOutputAppResponse implements ISystemDiseasesOutputAppResponse {
    data!: SystemDiseasesOutput;
    isSuccessful!: boolean;
    statusCode!: string | undefined;
    statusDescription!: string | undefined;

    constructor(data?: ISystemDiseasesOutputAppResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? SystemDiseasesOutput.fromJS(_data["data"]) : <any>undefined;
            this.isSuccessful = _data["isSuccessful"];
            this.statusCode = _data["statusCode"];
            this.statusDescription = _data["statusDescription"];
        }
    }

    static fromJS(data: any): SystemDiseasesOutputAppResponse {
        data = typeof data === 'object' ? data : {};
        let result = new SystemDiseasesOutputAppResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["isSuccessful"] = this.isSuccessful;
        data["statusCode"] = this.statusCode;
        data["statusDescription"] = this.statusDescription;
        return data; 
    }

    clone(): SystemDiseasesOutputAppResponse {
        const json = this.toJSON();
        let result = new SystemDiseasesOutputAppResponse();
        result.init(json);
        return result;
    }
}

export interface ISystemDiseasesOutputAppResponse {
    data: SystemDiseasesOutput;
    isSuccessful: boolean;
    statusCode: string | undefined;
    statusDescription: string | undefined;
}

export class EditSystemDiseaseInput implements IEditSystemDiseaseInput {
    name!: string;

    constructor(data?: IEditSystemDiseaseInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): EditSystemDiseaseInput {
        data = typeof data === 'object' ? data : {};
        let result = new EditSystemDiseaseInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data; 
    }

    clone(): EditSystemDiseaseInput {
        const json = this.toJSON();
        let result = new EditSystemDiseaseInput();
        result.init(json);
        return result;
    }
}

export interface IEditSystemDiseaseInput {
    name: string;
}

export class SystemDiseaseDtoAppResponse implements ISystemDiseaseDtoAppResponse {
    data!: SystemDiseaseDto;
    isSuccessful!: boolean;
    statusCode!: string | undefined;
    statusDescription!: string | undefined;

    constructor(data?: ISystemDiseaseDtoAppResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? SystemDiseaseDto.fromJS(_data["data"]) : <any>undefined;
            this.isSuccessful = _data["isSuccessful"];
            this.statusCode = _data["statusCode"];
            this.statusDescription = _data["statusDescription"];
        }
    }

    static fromJS(data: any): SystemDiseaseDtoAppResponse {
        data = typeof data === 'object' ? data : {};
        let result = new SystemDiseaseDtoAppResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["isSuccessful"] = this.isSuccessful;
        data["statusCode"] = this.statusCode;
        data["statusDescription"] = this.statusDescription;
        return data; 
    }

    clone(): SystemDiseaseDtoAppResponse {
        const json = this.toJSON();
        let result = new SystemDiseaseDtoAppResponse();
        result.init(json);
        return result;
    }
}

export interface ISystemDiseaseDtoAppResponse {
    data: SystemDiseaseDto;
    isSuccessful: boolean;
    statusCode: string | undefined;
    statusDescription: string | undefined;
}

export class CreateSystemMedicalVisitProcedureInput implements ICreateSystemMedicalVisitProcedureInput {
    name!: string;

    constructor(data?: ICreateSystemMedicalVisitProcedureInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): CreateSystemMedicalVisitProcedureInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateSystemMedicalVisitProcedureInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data; 
    }

    clone(): CreateSystemMedicalVisitProcedureInput {
        const json = this.toJSON();
        let result = new CreateSystemMedicalVisitProcedureInput();
        result.init(json);
        return result;
    }
}

export interface ICreateSystemMedicalVisitProcedureInput {
    name: string;
}

export class SystemMedicalVisitProcedureDto implements ISystemMedicalVisitProcedureDto {
    id!: number;
    status!: LookupStatus;
    name!: string | undefined;

    constructor(data?: ISystemMedicalVisitProcedureDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.status = _data["status"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): SystemMedicalVisitProcedureDto {
        data = typeof data === 'object' ? data : {};
        let result = new SystemMedicalVisitProcedureDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["status"] = this.status;
        data["name"] = this.name;
        return data; 
    }

    clone(): SystemMedicalVisitProcedureDto {
        const json = this.toJSON();
        let result = new SystemMedicalVisitProcedureDto();
        result.init(json);
        return result;
    }
}

export interface ISystemMedicalVisitProcedureDto {
    id: number;
    status: LookupStatus;
    name: string | undefined;
}

export class SystemMedicalVisitProceduresOutput implements ISystemMedicalVisitProceduresOutput {
    medicalVisitProcedures!: SystemMedicalVisitProcedureDto[] | undefined;

    constructor(data?: ISystemMedicalVisitProceduresOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["medicalVisitProcedures"])) {
                this.medicalVisitProcedures = [] as any;
                for (let item of _data["medicalVisitProcedures"])
                    this.medicalVisitProcedures!.push(SystemMedicalVisitProcedureDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SystemMedicalVisitProceduresOutput {
        data = typeof data === 'object' ? data : {};
        let result = new SystemMedicalVisitProceduresOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.medicalVisitProcedures)) {
            data["medicalVisitProcedures"] = [];
            for (let item of this.medicalVisitProcedures)
                data["medicalVisitProcedures"].push(item.toJSON());
        }
        return data; 
    }

    clone(): SystemMedicalVisitProceduresOutput {
        const json = this.toJSON();
        let result = new SystemMedicalVisitProceduresOutput();
        result.init(json);
        return result;
    }
}

export interface ISystemMedicalVisitProceduresOutput {
    medicalVisitProcedures: SystemMedicalVisitProcedureDto[] | undefined;
}

export class SystemMedicalVisitProceduresOutputAppResponse implements ISystemMedicalVisitProceduresOutputAppResponse {
    data!: SystemMedicalVisitProceduresOutput;
    isSuccessful!: boolean;
    statusCode!: string | undefined;
    statusDescription!: string | undefined;

    constructor(data?: ISystemMedicalVisitProceduresOutputAppResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? SystemMedicalVisitProceduresOutput.fromJS(_data["data"]) : <any>undefined;
            this.isSuccessful = _data["isSuccessful"];
            this.statusCode = _data["statusCode"];
            this.statusDescription = _data["statusDescription"];
        }
    }

    static fromJS(data: any): SystemMedicalVisitProceduresOutputAppResponse {
        data = typeof data === 'object' ? data : {};
        let result = new SystemMedicalVisitProceduresOutputAppResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["isSuccessful"] = this.isSuccessful;
        data["statusCode"] = this.statusCode;
        data["statusDescription"] = this.statusDescription;
        return data; 
    }

    clone(): SystemMedicalVisitProceduresOutputAppResponse {
        const json = this.toJSON();
        let result = new SystemMedicalVisitProceduresOutputAppResponse();
        result.init(json);
        return result;
    }
}

export interface ISystemMedicalVisitProceduresOutputAppResponse {
    data: SystemMedicalVisitProceduresOutput;
    isSuccessful: boolean;
    statusCode: string | undefined;
    statusDescription: string | undefined;
}

export class EditSystemMedicalVisitProcedureInput implements IEditSystemMedicalVisitProcedureInput {
    name!: string;

    constructor(data?: IEditSystemMedicalVisitProcedureInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): EditSystemMedicalVisitProcedureInput {
        data = typeof data === 'object' ? data : {};
        let result = new EditSystemMedicalVisitProcedureInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data; 
    }

    clone(): EditSystemMedicalVisitProcedureInput {
        const json = this.toJSON();
        let result = new EditSystemMedicalVisitProcedureInput();
        result.init(json);
        return result;
    }
}

export interface IEditSystemMedicalVisitProcedureInput {
    name: string;
}

export class SystemMedicalVisitProcedureDtoAppResponse implements ISystemMedicalVisitProcedureDtoAppResponse {
    data!: SystemMedicalVisitProcedureDto;
    isSuccessful!: boolean;
    statusCode!: string | undefined;
    statusDescription!: string | undefined;

    constructor(data?: ISystemMedicalVisitProcedureDtoAppResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? SystemMedicalVisitProcedureDto.fromJS(_data["data"]) : <any>undefined;
            this.isSuccessful = _data["isSuccessful"];
            this.statusCode = _data["statusCode"];
            this.statusDescription = _data["statusDescription"];
        }
    }

    static fromJS(data: any): SystemMedicalVisitProcedureDtoAppResponse {
        data = typeof data === 'object' ? data : {};
        let result = new SystemMedicalVisitProcedureDtoAppResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["isSuccessful"] = this.isSuccessful;
        data["statusCode"] = this.statusCode;
        data["statusDescription"] = this.statusDescription;
        return data; 
    }

    clone(): SystemMedicalVisitProcedureDtoAppResponse {
        const json = this.toJSON();
        let result = new SystemMedicalVisitProcedureDtoAppResponse();
        result.init(json);
        return result;
    }
}

export interface ISystemMedicalVisitProcedureDtoAppResponse {
    data: SystemMedicalVisitProcedureDto;
    isSuccessful: boolean;
    statusCode: string | undefined;
    statusDescription: string | undefined;
}

export class CreateSystemSurgeryInput implements ICreateSystemSurgeryInput {
    surgeriesProceduresIds!: number[] | undefined;
    name!: string;

    constructor(data?: ICreateSystemSurgeryInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["surgeriesProceduresIds"])) {
                this.surgeriesProceduresIds = [] as any;
                for (let item of _data["surgeriesProceduresIds"])
                    this.surgeriesProceduresIds!.push(item);
            }
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): CreateSystemSurgeryInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateSystemSurgeryInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.surgeriesProceduresIds)) {
            data["surgeriesProceduresIds"] = [];
            for (let item of this.surgeriesProceduresIds)
                data["surgeriesProceduresIds"].push(item);
        }
        data["name"] = this.name;
        return data; 
    }

    clone(): CreateSystemSurgeryInput {
        const json = this.toJSON();
        let result = new CreateSystemSurgeryInput();
        result.init(json);
        return result;
    }
}

export interface ICreateSystemSurgeryInput {
    surgeriesProceduresIds: number[] | undefined;
    name: string;
}

export class SystemSurgeriesOutput implements ISystemSurgeriesOutput {
    surgeries!: LookupDto[] | undefined;

    constructor(data?: ISystemSurgeriesOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["surgeries"])) {
                this.surgeries = [] as any;
                for (let item of _data["surgeries"])
                    this.surgeries!.push(LookupDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SystemSurgeriesOutput {
        data = typeof data === 'object' ? data : {};
        let result = new SystemSurgeriesOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.surgeries)) {
            data["surgeries"] = [];
            for (let item of this.surgeries)
                data["surgeries"].push(item.toJSON());
        }
        return data; 
    }

    clone(): SystemSurgeriesOutput {
        const json = this.toJSON();
        let result = new SystemSurgeriesOutput();
        result.init(json);
        return result;
    }
}

export interface ISystemSurgeriesOutput {
    surgeries: LookupDto[] | undefined;
}

export class SystemSurgeriesOutputAppResponse implements ISystemSurgeriesOutputAppResponse {
    data!: SystemSurgeriesOutput;
    isSuccessful!: boolean;
    statusCode!: string | undefined;
    statusDescription!: string | undefined;

    constructor(data?: ISystemSurgeriesOutputAppResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? SystemSurgeriesOutput.fromJS(_data["data"]) : <any>undefined;
            this.isSuccessful = _data["isSuccessful"];
            this.statusCode = _data["statusCode"];
            this.statusDescription = _data["statusDescription"];
        }
    }

    static fromJS(data: any): SystemSurgeriesOutputAppResponse {
        data = typeof data === 'object' ? data : {};
        let result = new SystemSurgeriesOutputAppResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["isSuccessful"] = this.isSuccessful;
        data["statusCode"] = this.statusCode;
        data["statusDescription"] = this.statusDescription;
        return data; 
    }

    clone(): SystemSurgeriesOutputAppResponse {
        const json = this.toJSON();
        let result = new SystemSurgeriesOutputAppResponse();
        result.init(json);
        return result;
    }
}

export interface ISystemSurgeriesOutputAppResponse {
    data: SystemSurgeriesOutput;
    isSuccessful: boolean;
    statusCode: string | undefined;
    statusDescription: string | undefined;
}

export class EditSystemSurgeryInput implements IEditSystemSurgeryInput {
    surgeriesProceduresIds!: number[] | undefined;
    name!: string;

    constructor(data?: IEditSystemSurgeryInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["surgeriesProceduresIds"])) {
                this.surgeriesProceduresIds = [] as any;
                for (let item of _data["surgeriesProceduresIds"])
                    this.surgeriesProceduresIds!.push(item);
            }
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): EditSystemSurgeryInput {
        data = typeof data === 'object' ? data : {};
        let result = new EditSystemSurgeryInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.surgeriesProceduresIds)) {
            data["surgeriesProceduresIds"] = [];
            for (let item of this.surgeriesProceduresIds)
                data["surgeriesProceduresIds"].push(item);
        }
        data["name"] = this.name;
        return data; 
    }

    clone(): EditSystemSurgeryInput {
        const json = this.toJSON();
        let result = new EditSystemSurgeryInput();
        result.init(json);
        return result;
    }
}

export interface IEditSystemSurgeryInput {
    surgeriesProceduresIds: number[] | undefined;
    name: string;
}

export class SystemSurgeryProcedureDto implements ISystemSurgeryProcedureDto {
    id!: number;
    points!: number;
    number!: number;

    constructor(data?: ISystemSurgeryProcedureDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.points = _data["points"];
            this.number = _data["number"];
        }
    }

    static fromJS(data: any): SystemSurgeryProcedureDto {
        data = typeof data === 'object' ? data : {};
        let result = new SystemSurgeryProcedureDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["points"] = this.points;
        data["number"] = this.number;
        return data; 
    }

    clone(): SystemSurgeryProcedureDto {
        const json = this.toJSON();
        let result = new SystemSurgeryProcedureDto();
        result.init(json);
        return result;
    }
}

export interface ISystemSurgeryProcedureDto {
    id: number;
    points: number;
    number: number;
}

export class SystemSurgeryDto implements ISystemSurgeryDto {
    id!: number;
    surgeriesProcedures!: SystemSurgeryProcedureDto[] | undefined;
    status!: LookupStatus;
    name!: string | undefined;

    constructor(data?: ISystemSurgeryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            if (Array.isArray(_data["surgeriesProcedures"])) {
                this.surgeriesProcedures = [] as any;
                for (let item of _data["surgeriesProcedures"])
                    this.surgeriesProcedures!.push(SystemSurgeryProcedureDto.fromJS(item));
            }
            this.status = _data["status"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): SystemSurgeryDto {
        data = typeof data === 'object' ? data : {};
        let result = new SystemSurgeryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (Array.isArray(this.surgeriesProcedures)) {
            data["surgeriesProcedures"] = [];
            for (let item of this.surgeriesProcedures)
                data["surgeriesProcedures"].push(item.toJSON());
        }
        data["status"] = this.status;
        data["name"] = this.name;
        return data; 
    }

    clone(): SystemSurgeryDto {
        const json = this.toJSON();
        let result = new SystemSurgeryDto();
        result.init(json);
        return result;
    }
}

export interface ISystemSurgeryDto {
    id: number;
    surgeriesProcedures: SystemSurgeryProcedureDto[] | undefined;
    status: LookupStatus;
    name: string | undefined;
}

export class SystemSurgeryDtoAppResponse implements ISystemSurgeryDtoAppResponse {
    data!: SystemSurgeryDto;
    isSuccessful!: boolean;
    statusCode!: string | undefined;
    statusDescription!: string | undefined;

    constructor(data?: ISystemSurgeryDtoAppResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? SystemSurgeryDto.fromJS(_data["data"]) : <any>undefined;
            this.isSuccessful = _data["isSuccessful"];
            this.statusCode = _data["statusCode"];
            this.statusDescription = _data["statusDescription"];
        }
    }

    static fromJS(data: any): SystemSurgeryDtoAppResponse {
        data = typeof data === 'object' ? data : {};
        let result = new SystemSurgeryDtoAppResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["isSuccessful"] = this.isSuccessful;
        data["statusCode"] = this.statusCode;
        data["statusDescription"] = this.statusDescription;
        return data; 
    }

    clone(): SystemSurgeryDtoAppResponse {
        const json = this.toJSON();
        let result = new SystemSurgeryDtoAppResponse();
        result.init(json);
        return result;
    }
}

export interface ISystemSurgeryDtoAppResponse {
    data: SystemSurgeryDto;
    isSuccessful: boolean;
    statusCode: string | undefined;
    statusDescription: string | undefined;
}

export class CreateSystemSurgeryProcedureInput implements ICreateSystemSurgeryProcedureInput {
    points!: number;
    number!: string | undefined;
    name!: string;

    constructor(data?: ICreateSystemSurgeryProcedureInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.points = _data["points"];
            this.number = _data["number"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): CreateSystemSurgeryProcedureInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateSystemSurgeryProcedureInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["points"] = this.points;
        data["number"] = this.number;
        data["name"] = this.name;
        return data; 
    }

    clone(): CreateSystemSurgeryProcedureInput {
        const json = this.toJSON();
        let result = new CreateSystemSurgeryProcedureInput();
        result.init(json);
        return result;
    }
}

export interface ICreateSystemSurgeryProcedureInput {
    points: number;
    number: string | undefined;
    name: string;
}

export class SystemSurgeryProceduresOutput implements ISystemSurgeryProceduresOutput {
    surgeryProcedures!: SystemSurgeryProcedureDto[] | undefined;

    constructor(data?: ISystemSurgeryProceduresOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["surgeryProcedures"])) {
                this.surgeryProcedures = [] as any;
                for (let item of _data["surgeryProcedures"])
                    this.surgeryProcedures!.push(SystemSurgeryProcedureDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SystemSurgeryProceduresOutput {
        data = typeof data === 'object' ? data : {};
        let result = new SystemSurgeryProceduresOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.surgeryProcedures)) {
            data["surgeryProcedures"] = [];
            for (let item of this.surgeryProcedures)
                data["surgeryProcedures"].push(item.toJSON());
        }
        return data; 
    }

    clone(): SystemSurgeryProceduresOutput {
        const json = this.toJSON();
        let result = new SystemSurgeryProceduresOutput();
        result.init(json);
        return result;
    }
}

export interface ISystemSurgeryProceduresOutput {
    surgeryProcedures: SystemSurgeryProcedureDto[] | undefined;
}

export class SystemSurgeryProceduresOutputAppResponse implements ISystemSurgeryProceduresOutputAppResponse {
    data!: SystemSurgeryProceduresOutput;
    isSuccessful!: boolean;
    statusCode!: string | undefined;
    statusDescription!: string | undefined;

    constructor(data?: ISystemSurgeryProceduresOutputAppResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? SystemSurgeryProceduresOutput.fromJS(_data["data"]) : <any>undefined;
            this.isSuccessful = _data["isSuccessful"];
            this.statusCode = _data["statusCode"];
            this.statusDescription = _data["statusDescription"];
        }
    }

    static fromJS(data: any): SystemSurgeryProceduresOutputAppResponse {
        data = typeof data === 'object' ? data : {};
        let result = new SystemSurgeryProceduresOutputAppResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["isSuccessful"] = this.isSuccessful;
        data["statusCode"] = this.statusCode;
        data["statusDescription"] = this.statusDescription;
        return data; 
    }

    clone(): SystemSurgeryProceduresOutputAppResponse {
        const json = this.toJSON();
        let result = new SystemSurgeryProceduresOutputAppResponse();
        result.init(json);
        return result;
    }
}

export interface ISystemSurgeryProceduresOutputAppResponse {
    data: SystemSurgeryProceduresOutput;
    isSuccessful: boolean;
    statusCode: string | undefined;
    statusDescription: string | undefined;
}

export class SystemSurgeryProcedureDtoAppResponse implements ISystemSurgeryProcedureDtoAppResponse {
    data!: SystemSurgeryProcedureDto;
    isSuccessful!: boolean;
    statusCode!: string | undefined;
    statusDescription!: string | undefined;

    constructor(data?: ISystemSurgeryProcedureDtoAppResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? SystemSurgeryProcedureDto.fromJS(_data["data"]) : <any>undefined;
            this.isSuccessful = _data["isSuccessful"];
            this.statusCode = _data["statusCode"];
            this.statusDescription = _data["statusDescription"];
        }
    }

    static fromJS(data: any): SystemSurgeryProcedureDtoAppResponse {
        data = typeof data === 'object' ? data : {};
        let result = new SystemSurgeryProcedureDtoAppResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["isSuccessful"] = this.isSuccessful;
        data["statusCode"] = this.statusCode;
        data["statusDescription"] = this.statusDescription;
        return data; 
    }

    clone(): SystemSurgeryProcedureDtoAppResponse {
        const json = this.toJSON();
        let result = new SystemSurgeryProcedureDtoAppResponse();
        result.init(json);
        return result;
    }
}

export interface ISystemSurgeryProcedureDtoAppResponse {
    data: SystemSurgeryProcedureDto;
    isSuccessful: boolean;
    statusCode: string | undefined;
    statusDescription: string | undefined;
}

export class EditSystemSurgeryProcedureInput implements IEditSystemSurgeryProcedureInput {
    points!: number;
    number!: string | undefined;
    name!: string;

    constructor(data?: IEditSystemSurgeryProcedureInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.points = _data["points"];
            this.number = _data["number"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): EditSystemSurgeryProcedureInput {
        data = typeof data === 'object' ? data : {};
        let result = new EditSystemSurgeryProcedureInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["points"] = this.points;
        data["number"] = this.number;
        data["name"] = this.name;
        return data; 
    }

    clone(): EditSystemSurgeryProcedureInput {
        const json = this.toJSON();
        let result = new EditSystemSurgeryProcedureInput();
        result.init(json);
        return result;
    }
}

export interface IEditSystemSurgeryProcedureInput {
    points: number;
    number: string | undefined;
    name: string;
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((<any>event.target).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}